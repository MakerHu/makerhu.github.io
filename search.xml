<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue 实现登录注册功能（前后端分离完整案例）</title>
    <url>/posts/78e35d03/</url>
    <content><![CDATA[<blockquote>
<p>本文面向小白，用 Vue 实现了登录注册的功能，并能够与 SpringBoot 后端进行数据交互。麻雀虽小，五脏俱全，本项目用到了 vue-router、axios、Element UI、代理服务器、导航守卫等技术或工具，与本博客的另一篇文章<a href="https://www.makerhu.com/posts/5b2ca0db/">快速上手SpringBoot项目（登录注册保姆级教程） | MakerHu 的博客</a> 共同组成了前后端分离项目的整体，适合小白上手 Vue + SpringBoot + Mysql 的项目开发。</p>
</blockquote>
<span id="more"></span>

<p><strong>未经允许请勿转载！</strong> 文章首发于<a href="https://www.makerhu.com/posts/78e35d03/">Vue 实现登录注册功能（前后端分离完整案例） | MakerHu 的博客</a></p>
<p>后端教程：<a href="https://www.makerhu.com/posts/5b2ca0db/">快速上手SpringBoot项目（登录注册保姆级教程） | MakerHu 的博客</a></p>
<p>项目演示：</p>
<p><img src="/posts/78e35d03/vue-login-demo-video.gif" alt="演示视频"></p>
<p><strong>说明：</strong></p>
<ul>
<li>本文中后半部分涉及到与后端的交互，需要先根据本人的另一个教程：<a href="https://www.makerhu.com/posts/5b2ca0db/">快速上手SpringBoot项目（登录注册保姆级教程） | MakerHu 的博客</a> 在本地运行起后端后才能测试，这个 Vue 前端项目是与前面这个教程的 SpringBoot 项目配套的前后端项目，因此<strong>建议先看完后端的文章再看此文章</strong>，当然如果只是要看前端登录注册页面的代码，也是没有问题的，只要忽略目录中<strong>前后端数据交互</strong>之后的内容就行了。</li>
<li>本文中🛠标志后面跟着的命令都是要在命令行窗口运行的命令，命令窗口用 cmd 就行了</li>
<li>文章最后有项目（前端和后端）的<strong>源代码</strong>哦</li>
</ul>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li><p>Node.js</p>
<p>Node 版本要求：Vue CLI 4.x 需要 <a href="https://nodejs.org/">Node.js</a> v8.9 或更高版本 (推荐 v10 以上)。</p>
</li>
</ul>
<h3 id="安装-Vue-脚手架"><a href="#安装-Vue-脚手架" class="headerlink" title="安装 Vue 脚手架"></a>安装 Vue 脚手架</h3><p><strong>官网地址：</strong><a href="https://cli.vuejs.org/zh/guide/installation.html">安装 | Vue CLI (vuejs.org)</a></p>
<ul>
<li><p>卸载旧版本的脚手架（之前安装过旧版本的脚手架才需要执行）：在任意地方打开 cmd 运行命令🛠<code>npm uninstall vue-cli -g</code></p>
<blockquote>
<p>关于旧版本</p>
<p>Vue CLI 的包名称由 <code>vue-cli</code> 改成了 <code>@vue/cli</code>。 如果你已经全局安装了旧版本的 <code>vue-cli</code> (1.x 或 2.x)，你需要先通过 <code>npm uninstall vue-cli -g</code> 或 <code>yarn global remove vue-cli</code> 卸载它。—— <a href="https://cli.vuejs.org/zh/guide/installation.html#:~:text=%E5%85%B3%E4%BA%8E%E6%97%A7%E7%89%88%E6%9C%AC,%E5%8D%B8%E8%BD%BD%E5%AE%83%E3%80%82">Vue 官网</a></p>
</blockquote>
</li>
<li><p>安装新版本的脚手架：🛠<code>npm install -g @vue/cli</code></p>
</li>
<li><p>检查脚手架是否安装成功（能看到版本号说明安装成功）：🛠<code>vue --version</code></p>
<p><img src="/posts/78e35d03/image-20220205224309328.png" alt="脚手架安装成功"></p>
</li>
<li><p>如果已经安装过新版的脚手架<code>@vue/cli</code>可进行全局升级：🛠<code>npm update -g @vue/cli</code></p>
</li>
</ul>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul>
<li><p>进入你要创建 Vue 项目的文件夹</p>
<p><img src="/posts/78e35d03/image-20220204105146311.png" alt="进入项目文件夹"></p>
</li>
<li><p>在 cmd 命令框中输入以下命令来创建一个新项目<br>🛠<code>vue create vue-login-demo</code></p>
<ul>
<li><p>其中<code>vue-login-demo</code>为项目名，可根据需要修改</p>
</li>
<li><p>选择 [Vue 2] 回车，因为是默认选项，可以直接回车</p>
<p><img src="/posts/78e35d03/image-20220204104255119.png" alt="创建项目"></p>
</li>
<li><p>成功提示</p>
<p><img src="/posts/78e35d03/image-20220204105731357.png" alt="项目创建成功显示"></p>
</li>
</ul>
</li>
<li><p>试运行新创建的初始化项目</p>
<ul>
<li>首先进入项目目录：🛠<code>cd vue-login-demo</code></li>
<li>运行项目：🛠<code>npm run serve</code></li>
</ul>
<p><img src="/posts/78e35d03/image-20220204110213333.png" alt="运行项目"></p>
</li>
<li><p>在浏览器地址栏中输入<code>http://localhost:8080/</code>回车，即可看到创建的初始化项目的效果，此页面是脚手架中写的一个HelloWorld示例页面，之后可以删了换成你写的页面。</p>
<p><img src="/posts/78e35d03/image-20220204110547005.png" alt="初始化项目效果"></p>
</li>
</ul>
<h2 id="Vue-项目的一些基本命令"><a href="#Vue-项目的一些基本命令" class="headerlink" title="Vue 项目的一些基本命令"></a>Vue 项目的一些基本命令</h2><ul>
<li>启动项目：在 Vue 项目的根目录中打开 cmd ，运行命令🛠<code>npm run serve</code></li>
<li>停止项目：在运行 Vue 项目的命令行窗口按快捷键 ctrl + C</li>
<li>安装插件：在 Vue 项目的根目录中打开 cmd，运行命令🛠<code>npm install xxx</code></li>
</ul>
<h2 id="项目文件结构"><a href="#项目文件结构" class="headerlink" title="项目文件结构"></a>项目文件结构</h2><blockquote>
<p>创建完项目后，为了帮助未来的开发，我们首先要熟悉一下刚刚通过 Vue 脚手架创建的项目中的每个文件的作用是什么</p>
</blockquote>
<h3 id="初始项目结构"><a href="#初始项目结构" class="headerlink" title="初始项目结构"></a>初始项目结构</h3><p><img src="/posts/78e35d03/image-20220204115003485.png" alt="项目文件结构"></p>
<ul>
<li><p><strong>public 文件夹</strong></p>
<ul>
<li><p><strong>favicon.ico：</strong>页面的图标</p>
</li>
<li><p><strong>index.html：</strong>页面的总入口，Vue项目一般是一个单页应用，也就是只有一个页面，我们看到的页面变化其实都是在这个页面中对某个组件进行局部刷新，这个页面中存在一个 id 为 app 的 div 标签，这个标签就是 App.vue 这个根组件的挂载点，可以简单理解为框架会把 App.vue 这个根节点放到 index.html 中的<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>这个位置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>src 文件夹</strong></p>
<ul>
<li><strong>assets 文件夹：</strong>资源文件，如存放一些图片 css 文件等</li>
<li><strong>components 文件夹：</strong>项目的公共组件，就是一些整个项目都有可能用到的组件，如一些公用的弹窗、输入框、按钮等</li>
</ul>
</li>
<li><p><strong>App.vue：</strong>项目的根组件，其他所有组件都包含在这个组件里，作为它的子组件或孙子组件</p>
</li>
<li><p><strong>main.js：</strong>整个项目的入口文件，在运行<code>npm run serve</code>命令时首先就运行了 main.js 这个文件，主要用来创建 Vue 实例，并作为桥梁将 App.vue 组件挂载到 index.html 中，此文件还负责全局引入一些插件并安装插件等功能，如引入 Element UI</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 Vue 的生产提示</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vue 实例对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),  <span class="comment">// render 函数将帮助解析模板，传入的参数 h 为一个函数，该函数可用来解析 App 这个组件</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">// 将 App.vue 组件挂载到 index.html 中的 id 为 app 的 div 标签上</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="补充项目结构"><a href="#补充项目结构" class="headerlink" title="补充项目结构"></a>补充项目结构</h3><p>这里列出一些在本项目写完后会多出来的一些文件目录，简单介绍，在这里看不懂正常，把整篇教程看完后就能看懂了。</p>
<p><img src="/posts/78e35d03/image-20220205181536482.png" alt="补充后的目录结构"></p>
<ul>
<li><p><strong>src 文件夹</strong></p>
<ul>
<li><strong>views 文件夹：</strong>用来存放页面组件，主要是一些页面路由跳转要刷新的那些最大的组件</li>
<li><strong>router 文件夹：</strong>用来配置项目的路由</li>
</ul>
</li>
<li><p><strong>vue.config.js 文件：</strong>配置文件，如配置代理服务器等</p>
</li>
</ul>
<h2 id="引入-Element-UI"><a href="#引入-Element-UI" class="headerlink" title="引入 Element UI"></a>引入 Element UI</h2><blockquote>
<p>Element UI 是由饿了么公司开发的一套桌面组件库，像一些表格、按钮、时间选择器等都可以直接使用，且简洁美观</p>
</blockquote>
<p>官网：<a href="https://element.eleme.cn/#/zh-CN/component/installation">组件 | Element</a></p>
<ul>
<li><p>安装 Element UI：在项目根目录中打开cmd，输入🛠<code>npm i element-ui -S</code> 没有报error就说明安装成功</p>
</li>
<li><p>引入 Element，在<code>src/main.js</code>中添加三行代码（下方中注释为Element 1、2、3的三行）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;	<span class="comment">// Element 1</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>; <span class="comment">// Element 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 Vue 的生产提示</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用插件</span></span><br><span class="line">Vue.use(ElementUI); <span class="comment">// Element 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vue 实例对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>src/App.vue</code> 中写个 Element 的按钮组件测试一下<code>&lt;el-button&gt;test&lt;/el-button&gt;</code></p>
<p><img src="/posts/78e35d03/image-20220204154825935.png" alt="测试ElementUI"></p>
<p><img src="/posts/78e35d03/image-20220204154955196.png" alt="测试ElementUI"></p>
</li>
</ul>
<h2 id="编写登录组件"><a href="#编写登录组件" class="headerlink" title="编写登录组件"></a>编写登录组件</h2><ul>
<li><p>在项目<code>src/views</code>文件夹下创建<code>login</code>文件夹并创建<code>Login.vue</code>组件</p>
<p><img src="/posts/78e35d03/image-20220204161201654.png" alt="创建Login组件"></p>
</li>
<li><p>在 App.vue 中注册 Login.vue 组件，把没用的 HelloWorld 都删了（红框部分）添加绿框部分的代码</p>
<p><img src="/posts/78e35d03/image-20220204164603724.png" alt="注册 Login.vue 组件"></p>
<p><strong>修改后的App.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;Login&gt;&lt;&#x2F;Login&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Login from &#39;.&#x2F;views&#x2F;login&#x2F;Login.vue&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Login</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>测试组件是否正常显示</p>
<p>先在 Login.vue 组件中写个最简单的文本显示</p>
<p><strong>Login.vue：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Login test&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>查看页面是否变更，如果正常显示 Login.vue 里的内容则说明 App.vue 中 Login 组件注册成功</p>
<p><img src="/posts/78e35d03/image-20220204165553214.png" alt="测试组件是否注册成功"></p>
</li>
<li><p>完善 Login.vue 组件的页面、样式和一些基本逻辑。到 Element UI 中找到表单组件，这里使用的是自定义校验规则这个例子<a href="https://element.eleme.cn/#/zh-CN/component/form">Element UI 表单</a>，将该例子进行修改成为登录组件</p>
<p><strong>修改后的 Login.vue：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-card class&#x3D;&quot;box-card&quot;&gt;</span><br><span class="line">      &lt;h2&gt;登录&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;el-form</span><br><span class="line">        :model&#x3D;&quot;ruleForm&quot;</span><br><span class="line">        status-icon</span><br><span class="line">        :rules&#x3D;&quot;rules&quot;</span><br><span class="line">        ref&#x3D;&quot;ruleForm&quot;</span><br><span class="line">        label-position&#x3D;&quot;left&quot;</span><br><span class="line">        label-width&#x3D;&quot;70px&quot;</span><br><span class="line">        class&#x3D;&quot;login-from&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;用户名&quot; prop&#x3D;&quot;uname&quot;&gt;</span><br><span class="line">          &lt;el-input v-model&#x3D;&quot;ruleForm.uname&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">          &lt;el-input</span><br><span class="line">            type&#x3D;&quot;password&quot;</span><br><span class="line">            v-model&#x3D;&quot;ruleForm.password&quot;</span><br><span class="line">            autocomplete&#x3D;&quot;off&quot;</span><br><span class="line">          &gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;&#x2F;el-form&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;btnGroup&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;submitForm(&#39;ruleForm&#39;)&quot;</span><br><span class="line">          &gt;登录&lt;&#x2F;el-button</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;resetForm(&#39;ruleForm&#39;)&quot;&gt;重置&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;router-link to&#x3D;&quot;&#x2F;register&quot;&gt;</span><br><span class="line">          &lt;el-button style&#x3D;&quot;margin-left:10px&quot;&gt;注册&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;el-card&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ruleForm: &#123;</span><br><span class="line">        uname: &quot;&quot;,</span><br><span class="line">        password: &quot;&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        uname: [</span><br><span class="line">          &#123; required: true, message: &quot;用户名不能为空！&quot;, trigger: &quot;blur&quot; &#125;,</span><br><span class="line">        ],</span><br><span class="line">        password: [</span><br><span class="line">          &#123; required: true, message: &quot;密码不能为空！&quot;, trigger: &quot;blur&quot; &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          alert(&quot;submit!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&quot;error submit!!&quot;);</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    resetForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].resetFields();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.box-card &#123;</span><br><span class="line">  margin: auto auto;</span><br><span class="line">  width: 400px;</span><br><span class="line">&#125;</span><br><span class="line">.login-from &#123;</span><br><span class="line">  margin: auto auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>显示效果：</p>
<p><img src="/posts/78e35d03/image-20220204230813619.png" alt="登录页面初步完成"></p>
</li>
</ul>
<h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><blockquote>
<p>在写网站应用的过程中，离不开一个功能，就是页面的跳转，而在 Vue 这种单页应用中，一个网站就只有一个页面，我们看到所谓页面的“跳转”其实只是同一个页面中的局部组件的刷新，而路由的指的是浏览器地址栏中的路径与组件有着一一对应的关系，当输入指定的地址时，页面中的某个区域的组件会替换成该地址对应的组件。</p>
</blockquote>
<p>官网：<a href="https://router.vuejs.org/zh/installation.html">安装 | Vue Router (vuejs.org)</a></p>
<ul>
<li><p>安装路由插件</p>
<p>在项目根目录中打开cmd，输入🛠<code>npm install vue-router</code></p>
</li>
<li><p>在<code>src</code>下创建 <code>router</code> 文件夹，并在<code>router</code>文件夹下创建<code>index.js</code>文件，该问价作为整个项目路由的配置文件</p>
<p><img src="/posts/78e35d03/image-20220204180700385.png" alt="路由配置文件"></p>
</li>
<li><p><code>src/router/index.js</code>文件内容，这里实现的是路径’/‘，’/login’都跳转到 Login.vue 组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此文件专门负责项目的路由</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;../views/login/Login&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,    <span class="comment">// 路由模式，该模式不会在地址中显示井号#</span></span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/&#x27;</span>,          <span class="comment">// 路径</span></span><br><span class="line">            redirect: <span class="string">&#x27;/login&#x27;</span>  <span class="comment">// 重定向</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/login&#x27;</span>,     <span class="comment">// 路径</span></span><br><span class="line">            component: Login    <span class="comment">// 跳转到的组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>引入路由插件，在<code>src/main.js</code>中添加三行代码（下方中注释为 路由 1、2、3、4 的四行）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span> <span class="comment">// 路由 1</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span> <span class="comment">// 路由 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 Vue 的生产提示</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用插件</span></span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line">Vue.use(VueRouter) <span class="comment">// 路由 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vue 实例对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  router <span class="comment">// 路由 4</span></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>src/App.vue</code>中将<code>&lt;router-view /&gt;</code>放到路由跳转时，页面需要局部刷新的部分，并把刚刚在<code>App.vue</code>中写死的组件给删了（删除红色，添加绿色框中的内容）</p>
<p><img src="/posts/78e35d03/image-20220204181348812.png" alt="src/App.vue"></p>
<p>修改后的<code>App.vue</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>检查地址栏跳转是否正常</p>
<p><img src="/posts/78e35d03/image-20220204231001677.png" alt="/login路径正常显示"></p>
<p><img src="/posts/78e35d03/image-20220204182056530.png" alt="随机填写路径按预期不显示"></p>
</li>
</ul>
<h2 id="编写注册组件"><a href="#编写注册组件" class="headerlink" title="编写注册组件"></a>编写注册组件</h2><ul>
<li><p>在项目<code>src/views</code>文件夹下创建<code>register</code>文件夹并创建<code>Register.vue</code>组件</p>
<p><img src="/posts/78e35d03/image-20220204231156617.png" alt="注册页面组件"></p>
</li>
<li><p><strong>Register.vue 组件代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-card class&#x3D;&quot;box-card&quot;&gt;</span><br><span class="line">      &lt;h2&gt;注册&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;el-form</span><br><span class="line">        :model&#x3D;&quot;ruleForm&quot;</span><br><span class="line">        status-icon</span><br><span class="line">        :rules&#x3D;&quot;rules&quot;</span><br><span class="line">        ref&#x3D;&quot;ruleForm&quot;</span><br><span class="line">        label-position&#x3D;&quot;left&quot;</span><br><span class="line">        label-width&#x3D;&quot;80px&quot;</span><br><span class="line">        class&#x3D;&quot;demo-ruleForm&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;用户名&quot; prop&#x3D;&quot;uname&quot;&gt;</span><br><span class="line">          &lt;el-input v-model&#x3D;&quot;ruleForm.uname&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;pass&quot;&gt;</span><br><span class="line">          &lt;el-input</span><br><span class="line">            type&#x3D;&quot;password&quot;</span><br><span class="line">            v-model&#x3D;&quot;ruleForm.pass&quot;</span><br><span class="line">            autocomplete&#x3D;&quot;off&quot;</span><br><span class="line">          &gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;确认密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">          &lt;el-input</span><br><span class="line">            type&#x3D;&quot;password&quot;</span><br><span class="line">            v-model&#x3D;&quot;ruleForm.password&quot;</span><br><span class="line">            autocomplete&#x3D;&quot;off&quot;</span><br><span class="line">          &gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;&#x2F;el-form&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;btnGroup&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;submitForm(&#39;ruleForm&#39;)&quot;</span><br><span class="line">          &gt;提交&lt;&#x2F;el-button</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;resetForm(&#39;ruleForm&#39;)&quot;&gt;重置&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;goBack&quot;&gt;返回&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;el-card&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    var validatePass &#x3D; (rule, value, callback) &#x3D;&gt; &#123;</span><br><span class="line">      if (value &#x3D;&#x3D;&#x3D; &quot;&quot;) &#123;</span><br><span class="line">        callback(new Error(&quot;请输入密码&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (this.ruleForm.checkPass !&#x3D;&#x3D; &quot;&quot;) &#123;</span><br><span class="line">          this.$refs.ruleForm.validateField(&quot;checkPass&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var validatePass2 &#x3D; (rule, value, callback) &#x3D;&gt; &#123;</span><br><span class="line">      if (value &#x3D;&#x3D;&#x3D; &quot;&quot;) &#123;</span><br><span class="line">        callback(new Error(&quot;请再次输入密码&quot;));</span><br><span class="line">      &#125; else if (value !&#x3D;&#x3D; this.ruleForm.pass) &#123;</span><br><span class="line">        callback(new Error(&quot;两次输入密码不一致!&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      ruleForm: &#123;</span><br><span class="line">        uname: &quot;&quot;,</span><br><span class="line">        pass: &quot;&quot;,</span><br><span class="line">        password: &quot;&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        uname: [</span><br><span class="line">          &#123; required: true, message: &quot;用户名不能为空！&quot;, trigger: &quot;blur&quot; &#125;,</span><br><span class="line">        ],</span><br><span class="line">        pass: [&#123; required: true, validator: validatePass, trigger: &quot;blur&quot; &#125;],</span><br><span class="line">        password: [</span><br><span class="line">          &#123; required: true, validator: validatePass2, trigger: &quot;blur&quot; &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          alert(&quot;submit!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&quot;error submit!!&quot;);</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    resetForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].resetFields();</span><br><span class="line">    &#125;,</span><br><span class="line">    goBack() &#123;</span><br><span class="line">      this.$router.go(-1);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.box-card &#123;</span><br><span class="line">  margin: auto auto;</span><br><span class="line">  width: 400px;</span><br><span class="line">&#125;</span><br><span class="line">.login-from &#123;</span><br><span class="line">  margin: auto auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置注册页面路由。在<code>src/router/index.js</code>中添加红框中的代码</p>
<p><img src="/posts/78e35d03/image-20220204231614360.png" alt="配置注册页面路由"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此文件专门负责项目的路由</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;../views/login/Login&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Register <span class="keyword">from</span> <span class="string">&#x27;../views/register/Register&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,    <span class="comment">// 路由模式，该模式不会在地址中显示井号#</span></span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/&#x27;</span>,          <span class="comment">// 路径</span></span><br><span class="line">            redirect: <span class="string">&#x27;/login&#x27;</span>  <span class="comment">// 重定向</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/login&#x27;</span>,     <span class="comment">// 路径</span></span><br><span class="line">            component: Login    <span class="comment">// 跳转到的组件</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/register&#x27;</span>,     <span class="comment">// 路径</span></span><br><span class="line">            component: Register    <span class="comment">// 跳转到的组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>测试页面与路由。在地址栏中输入<code>/register</code>，点击返回按钮正常跳转</p>
<p><img src="/posts/78e35d03/image-20220204231848142.png" alt="检查注册页面"></p>
</li>
</ul>
<h2 id="编写首页组件"><a href="#编写首页组件" class="headerlink" title="编写首页组件"></a>编写首页组件</h2><blockquote>
<p>本教程的首页只是为了展示后端返回的数据，因此只实现了将数据显示到页面上，稍微有那么一丝丝简陋，见谅</p>
</blockquote>
<ul>
<li><p>在项目<code>src/views</code>文件夹下创建<code>home</code>文件夹并创建<code>Home.vue</code>组件</p>
<p><img src="/posts/78e35d03/image-20220204233952220.png" alt="创建首页组件"></p>
</li>
<li><p><strong>Home.vue 组件代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;欢迎&#123;&#123; user.uname &#125;&#125;！您的 uid 为&#123;&#123; user.uid &#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;login&quot;&gt;</span><br><span class="line">      &lt;el-button&gt; 登出 &lt;&#x2F;el-button&gt;</span><br><span class="line">    &lt;&#x2F;router-link&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        uname: &quot;&quot;,</span><br><span class="line">        uid: null,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置首页路由。在<code>src/router/index.js</code>中添加红框中的代码</p>
<p><img src="/posts/78e35d03/image-20220204234200544.png" alt="配置首页路由"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此文件专门负责项目的路由</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;../views/login/Login&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Register <span class="keyword">from</span> <span class="string">&#x27;../views/register/Register&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../views/home/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,    <span class="comment">// 路由模式，该模式不会在地址中显示井号#</span></span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/&#x27;</span>,          <span class="comment">// 路径</span></span><br><span class="line">            redirect: <span class="string">&#x27;/login&#x27;</span>  <span class="comment">// 重定向</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/login&#x27;</span>,     <span class="comment">// 路径</span></span><br><span class="line">            component: Login    <span class="comment">// 跳转到的组件</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/register&#x27;</span>,     <span class="comment">// 路径</span></span><br><span class="line">            component: Register    <span class="comment">// 跳转到的组件</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/home&#x27;</span>,     <span class="comment">// 路径</span></span><br><span class="line">            component: Home    <span class="comment">// 跳转到的组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>测试页面与路由。在地址栏中输入<code>/home</code>，点击登出按钮，正常跳转</p>
<p><img src="/posts/78e35d03/image-20220204234423069.png" alt="测试效果"></p>
</li>
</ul>
<p><strong>至此所有的本 demo 的所有页面都写完了，一些简单的前端跳转逻辑也已完成，接下来就需要与后端进行交互，实现我们的登录注册功能。</strong></p>
<h2 id="前后端数据交互"><a href="#前后端数据交互" class="headerlink" title="前后端数据交互"></a>前后端数据交互</h2><blockquote>
<p>在开始前后端数据交互的功能开发之前，我们应该得先有个后端，并且这个后端已经写好了登录注册的相关功能接口，这样我们就可以直接请求接口数据了。别担心，后端的项目我早已准备好了🎉<br><a href="https://www.makerhu.com/posts/5b2ca0db/">快速上手SpringBoot项目（登录注册保姆级教程） | www.makerhu.com/posts/5b2ca0db/</a><br>这个教程里详细介绍了如何开发一个 SpringBoot 后端的登陆注册小项目，与这个项目是配套的，教程的最后也附上了项目的源代码，可以直接克隆下来配置一下数据库就能运行了，如何配置数据库教程里也有详细的介绍。以下的数据请求功能我都是直接请求这个后端项目的接口，请求地址是 localhost:8081 在此就不赘述如何在本地启动后端项目了，详见上方的教程链接。</p>
</blockquote>
<p><strong>注：在写涉及到与后端交互的功能时一定记得要先把后端启动起来，否则是找不到后端的，一般是在前端开发全程都运行着后端的。</strong></p>
<h3 id="后端接口说明"><a href="#后端接口说明" class="headerlink" title="后端接口说明"></a>后端接口说明</h3><p>由于本项目需要向后端项目请求数据，因此我们需要先知道后端都实现了什么接口。在后端项目中一共就实现了两个接口，分别是登录接口和注册接口，以下是接口说明（可以先跳过，等到实现登录注册功能时再回来看）：</p>
<ul>
<li><p><strong>登录接口</strong></p>
<ul>
<li><p>请求地址：<a href="http://localhost:8081/user/login">http://localhost:8081/user/login</a></p>
</li>
<li><p>请求方法：post</p>
</li>
<li><p>请求参数：</p>
<ul>
<li>uname：用户名，字符串类型</li>
<li>password：密码，字符串类型</li>
</ul>
<p>请求示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">params: &#123;</span><br><span class="line">	uname: &#x27;makerhu&#x27;,</span><br><span class="line">	password: &#x27;123&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>成功响应编码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;登录成功！&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;uid&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;uname&quot;</span>: <span class="string">&quot;makerhu&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>失败响应编码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;账号或密码错误！&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>注册接口</strong></p>
<ul>
<li><p>请求地址：<a href="http://localhost:8081/user/register">http://localhost:8081/user/register</a></p>
</li>
<li><p>请求方法：post</p>
</li>
<li><p>请求参数：</p>
<ul>
<li>json 对象，包含用户名 uname 和密码 password</li>
</ul>
<p>请求示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    uname: &#x27;makerhu&#x27;,</span><br><span class="line">    password: &#x27;123&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>成功响应编码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;注册成功！&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;uid&quot;</span>: <span class="number">7</span>,</span><br><span class="line">        <span class="attr">&quot;uname&quot;</span>: <span class="string">&quot;user6&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>失败响应编码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;456&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;用户名已存在！&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="安装-axios"><a href="#安装-axios" class="headerlink" title="安装 axios"></a>安装 axios</h3><blockquote>
<p>axios 简单理解就是用来帮助我们实现网络数据请求的一个插件，我们可以通过它与后端进行数据交互</p>
</blockquote>
<p>axios 中文文档：<a href="http://www.axios-js.com/zh-cn/docs/#axios-API">axios中文文档|axios中文网 | axios (axios-js.com)</a></p>
<ul>
<li><p><strong>安装 axios</strong></p>
<p>在项目根目录中打开 cmd，输入🛠<code>npm install axios</code>，等待结束后没有显示 error 关键字即成功</p>
</li>
<li><p><strong>在项目中引入使用 axios</strong>，在<code>src/main.js</code>中添加红色框中的三行代码</p>
<p><img src="/posts/78e35d03/image-20220205145546498.png" alt="引用axios插件"></p>
<p>修改后的 <code>main.js</code> 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueAxios <span class="keyword">from</span> <span class="string">&#x27;vue-axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 Vue 的生产提示</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用插件</span></span><br><span class="line">Vue.use(ElementUI) <span class="comment">// element ui 插件</span></span><br><span class="line">Vue.use(VueRouter) <span class="comment">// 路由插件</span></span><br><span class="line">Vue.use(VueAxios, axios) <span class="comment">// 使用 axios 插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vue 实例对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),  <span class="comment">// render 函数将帮助解析模板，传入的参数 h 为一个函数，该函数可用来解析 App 这个组件</span></span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">// 将 App.vue 组件挂载到 index.html 中的 id 为 app 的 div 标签上</span></span><br></pre></td></tr></table></figure>

<p>现在我们就能在 Vue 实例中通过<code>this.axios</code>调用了。</p>
</li>
<li><p><strong>如何使用 axios</strong></p>
<p>在 vue 的方法中我们可以通过下面例子中的方式使用 axios, 配合接口说明就能与后端进行数据交互了，具体用法见官方文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.axios.post(&#123;</span><br><span class="line">  method: <span class="string">&#x27;post&#x27;</span>,		<span class="comment">// 请求方法</span></span><br><span class="line">  url: <span class="string">&#x27;http://localhost:8081/user/login&#x27;</span>,	<span class="comment">// 请求地址</span></span><br><span class="line">  data: &#123;	<span class="comment">// 请求参数</span></span><br><span class="line">    cname: <span class="string">&#x27;makerhu&#x27;</span>,</span><br><span class="line">    password: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;	<span class="comment">// 请求成功回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;	<span class="comment">// 请求异常回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置代理服务器"><a href="#配置代理服务器" class="headerlink" title="配置代理服务器"></a>配置代理服务器</h3><blockquote>
<p>在正式开始写登录注册与后端的交互之前，我们先在前端处理一下跨域问题。跨域问题可以简单理解成如果你的前端项目的<strong>IP地址</strong>和<strong>端口号</strong>和后端的<strong>IP地址</strong>和<strong>端口号</strong>不一样，就会导致前端无法获取到数据，这是一个规定。而在前后端分离开发的项目中，前后端项目的端口号一般都是不一样的，比如我们这个项目的前端端口号是 8080，后端端口号是 8081，所以一定会造成跨域访问的问题，跨域访问的问题可以在前端解决也可以在后端解决，前端一般采用代理服务器的方式，因此这里我们也通过配置代理服务器的方法来处理跨域问题。</p>
</blockquote>
<p><strong>代理服务器是如何解决跨域问题的呢？</strong></p>
<p>简单来说就是代理服务器代理前端项目访问后端，并且在访问后端的时候把自己的 IP 地址和端口号伪装成和后端一模一样的，这样就能把后端骗过去从而获取到数据啦。</p>
<p>实现起来其实也很简单，只要在项目根目录（和 src 文件夹平级）中添加一个文件<code>vue.config.js</code>添加几行配置就行了，下面是<code>vue.config.js</code>文件的配置内容</p>
<p><img src="/posts/78e35d03/image-20220205163502539.png" alt="vue.config.js文件"></p>
<p><strong>vue.config.js 文件：</strong></p>
<p><strong>注意修改完 vue.config.js 这个配置文件需要重新启动前端项目才能生效</strong>，在项目根目录中打开cmd，输入 🛠<code>npm run serve</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    lintOnSave: <span class="literal">false</span>, <span class="comment">// 关闭语法检测</span></span><br><span class="line">    <span class="comment">// 开启代理服务器</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        <span class="comment">// 代理服务器可以将路由中的指定前缀转发到指定的后端服务器中</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&#x27;http://localhost:8081&#x27;</span>,</span><br><span class="line">                ws: <span class="literal">true</span>, <span class="comment">// 是否启用websockets</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>,  <span class="comment">// 代理时是否更改host</span></span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> <span class="comment">//这里理解成用&#x27;/api&#x27;代替target里面的地址</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置解释</strong></p>
<p>这里我们主要看一下 proxy 里的这几个配置（我把上面暂时不需要关注或不重要的配置先删了）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://localhost:8081&#x27;,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">            &#x27;^/api&#x27;: &#x27;&#x27; //这里理解成用&#x27;/api&#x27;代替target里面的地址</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>‘/api’：</strong>这个键值对，也就是**’/api’**和它后面跟的一个大括号为一个键值对，这个键值对就是一个代理，它代理的是所有请求地址中以<code>/api</code>开头的请求，</li>
<li><strong>target：</strong>这个属性是配置这个代理服务器要帮忙代理的后端服务器的地址，本项目的后端地址是<code>http://localhost:8081</code></li>
<li><strong>pathRewrite：</strong>这个属性的作用是在代理服务器请求后端时，把地址中的<code>/api</code>替换成空字符串，比如代理请求后端的登录接口时，如果没有配置这个属性，请求的地址将是<code>http://localhost:8081/api/user/login</code>，而我们查看本文前面的<strong>后端接口说明</strong>，发现后端的登录接口地址是<code>http://localhost:8081/user/login</code>，因此我们需要配置 <strong>pathRewrite</strong> 这个属性将<code>/api</code>变为空字符串</li>
</ul>
<p><strong>使用代理</strong></p>
<p>其实也没有什么特别的使用方式，只要在使用 axios 时，把请求地址改为代理的前缀就行了，本项目的代理前缀是<code>/api</code></p>
<p>对比：</p>
<ul>
<li><p>未使用代理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.axios.post(&#123;</span><br><span class="line">  method: <span class="string">&#x27;post&#x27;</span>,		<span class="comment">// 请求方法</span></span><br><span class="line">  url: <span class="string">&#x27;http://localhost:8081/user/login&#x27;</span>,	<span class="comment">// 请求地址</span></span><br><span class="line">  data: &#123;	<span class="comment">// 请求参数</span></span><br><span class="line">    cname: <span class="string">&#x27;makerhu&#x27;</span>,</span><br><span class="line">    password: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用代理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.axios.post(&#123;</span><br><span class="line">  method: <span class="string">&#x27;post&#x27;</span>,		<span class="comment">// 请求方法</span></span><br><span class="line">  url: <span class="string">&#x27;/api/user/login&#x27;</span>,	<span class="comment">// 请求地址</span></span><br><span class="line">  data: &#123;	<span class="comment">// 请求参数</span></span><br><span class="line">    cname: <span class="string">&#x27;makerhu&#x27;</span>,</span><br><span class="line">    password: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样代理服务器就会自动把<code>&#39;/api/user/login&#39;</code>改成<code>&#39;http://localhost:8081/user/login&#39;</code></p>
<p>至此，万事俱备，只欠东风了。接下来我们就把前文说到的技术都搬到登录注册组件中，在添加一点点细节就完事啦！</p>
<h3 id="完善登录功能"><a href="#完善登录功能" class="headerlink" title="完善登录功能"></a>完善登录功能</h3><ul>
<li><p><strong>完善 submitForm 方法</strong>，这个函数是在点击登录按钮会被调用，因此我们要在这个方法里把登录的用户名和密码发到后端</p>
<p>这里就直接贴出完善后的登录组件代码了，变化的地方主要就是在 submitForm 函数里，代码里有详细注释，其他的就是加了一个按钮显示加载动画的功能，不是很重要。</p>
<p><strong>src/views/login/Login.vue：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-card class&#x3D;&quot;box-card&quot;&gt;</span><br><span class="line">      &lt;h2&gt;登录&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;el-form</span><br><span class="line">        :model&#x3D;&quot;ruleForm&quot;</span><br><span class="line">        status-icon</span><br><span class="line">        :rules&#x3D;&quot;rules&quot;</span><br><span class="line">        ref&#x3D;&quot;ruleForm&quot;</span><br><span class="line">        label-position&#x3D;&quot;left&quot;</span><br><span class="line">        label-width&#x3D;&quot;70px&quot;</span><br><span class="line">        class&#x3D;&quot;login-from&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;用户名&quot; prop&#x3D;&quot;uname&quot;&gt;</span><br><span class="line">          &lt;el-input v-model&#x3D;&quot;ruleForm.uname&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">          &lt;el-input</span><br><span class="line">            type&#x3D;&quot;password&quot;</span><br><span class="line">            v-model&#x3D;&quot;ruleForm.password&quot;</span><br><span class="line">            autocomplete&#x3D;&quot;off&quot;</span><br><span class="line">          &gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;&#x2F;el-form&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;btnGroup&quot;&gt;</span><br><span class="line">        &lt;el-button</span><br><span class="line">          type&#x3D;&quot;primary&quot;</span><br><span class="line">          @click&#x3D;&quot;submitForm(&#39;ruleForm&#39;)&quot;</span><br><span class="line">          v-loading&#x3D;&quot;loading&quot;</span><br><span class="line">          &gt;登录&lt;&#x2F;el-button</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;resetForm(&#39;ruleForm&#39;)&quot;&gt;重置&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;router-link to&#x3D;&quot;&#x2F;register&quot;&gt;</span><br><span class="line">          &lt;el-button style&#x3D;&quot;margin-left: 10px&quot;&gt;注册&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;&#x2F;router-link&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;el-card&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      ruleForm: &#123;</span><br><span class="line">        uname: &quot;&quot;,</span><br><span class="line">        password: &quot;&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        uname: [</span><br><span class="line">          &#123; required: true, message: &quot;用户名不能为空！&quot;, trigger: &quot;blur&quot; &#125;,</span><br><span class="line">        ],</span><br><span class="line">        password: [</span><br><span class="line">          &#123; required: true, message: &quot;密码不能为空！&quot;, trigger: &quot;blur&quot; &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      loading: false, &#x2F;&#x2F; 是否显示加载动画</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitForm(formName) &#123;</span><br><span class="line">      &#x2F;&#x2F; 验证表单中的账号密码是否有效，因为在上面rules中定义为了必填 required: true</span><br><span class="line">      this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 点击登录后，让登录按钮开始转圈圈（展示加载动画）</span><br><span class="line">        this.loading &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 如果经过校验，账号密码都不为空，则发送请求到后端登录接口</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          let _this &#x3D; this;</span><br><span class="line">          &#x2F;&#x2F; 使用 axios 将登录信息发送到后端</span><br><span class="line">          this.axios(&#123;</span><br><span class="line">            url: &quot;&#x2F;api&#x2F;user&#x2F;login&quot;,               &#x2F;&#x2F; 请求地址</span><br><span class="line">            method: &quot;post&quot;,                       &#x2F;&#x2F; 请求方法</span><br><span class="line">            headers: &#123;                            &#x2F;&#x2F; 请求头</span><br><span class="line">              &quot;Content-Type&quot;: &quot;application&#x2F;json&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            params: &#123;                             &#x2F;&#x2F; 请求参数</span><br><span class="line">              uname: _this.ruleForm.uname,</span><br><span class="line">              password: _this.ruleForm.password,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;).then((res) &#x3D;&gt; &#123; &#x2F;&#x2F; 当收到后端的响应时执行该括号内的代码，res 为响应信息，也就是后端返回的信息</span><br><span class="line">            if (res.data.code &#x3D;&#x3D;&#x3D; &quot;0&quot;) &#123;  &#x2F;&#x2F; 当响应的编码为 0 时，说明登录成功</span><br><span class="line">              &#x2F;&#x2F; 将用户信息存储到sessionStorage中</span><br><span class="line">              sessionStorage.setItem(&quot;userInfo&quot;, JSON.stringify(res.data.data));</span><br><span class="line">              &#x2F;&#x2F; 跳转页面到首页</span><br><span class="line">              this.$router.push(&#39;&#x2F;home&#39;);</span><br><span class="line">              &#x2F;&#x2F; 显示后端响应的成功信息</span><br><span class="line">              this.$message(&#123;</span><br><span class="line">                message: res.data.msg,</span><br><span class="line">                type: &quot;success&quot;,</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125; else &#123;  &#x2F;&#x2F; 当响应的编码不为 0 时，说明登录失败</span><br><span class="line">              &#x2F;&#x2F; 显示后端响应的失败信息</span><br><span class="line">              this.$message(&#123;</span><br><span class="line">                message: res.data.msg,</span><br><span class="line">                type: &quot;warning&quot;,</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 不管响应成功还是失败，收到后端响应的消息后就不再让登录按钮显示加载动画了</span><br><span class="line">            _this.loading &#x3D; false;</span><br><span class="line">            console.log(res);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; else &#123;  &#x2F;&#x2F; 如果账号或密码有一个没填，就直接提示必填，不向后端请求</span><br><span class="line">          console.log(&quot;error submit!!&quot;);</span><br><span class="line">          this.loading &#x3D; false;</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    resetForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].resetFields();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&#x2F;* 设置登录面板居中，宽度为400px *&#x2F;</span><br><span class="line">.box-card &#123;</span><br><span class="line">  margin: auto auto;</span><br><span class="line">  width: 400px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 设置登录面板中的表单居中 *&#x2F;</span><br><span class="line">.login-from &#123;</span><br><span class="line">  margin: auto auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>写完后先测试一下登录功能能否正常使用，由于现在后端没有注册任何账号，正常应该提示“账号或密码错误”。</p>
<p><img src="/posts/78e35d03/image-20220205172440156.png" alt="测试登录"></p>
</li>
</ul>
<h3 id="完善注册功能"><a href="#完善注册功能" class="headerlink" title="完善注册功能"></a>完善注册功能</h3><p>注册功能与登录功能几乎一致，就是向后端请求参数的方式不太一样，具体看接口说明，这里也贴上代码，有详细注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-card class&#x3D;&quot;box-card&quot;&gt;</span><br><span class="line">      &lt;h2&gt;注册&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;el-form</span><br><span class="line">        :model&#x3D;&quot;ruleForm&quot;</span><br><span class="line">        status-icon</span><br><span class="line">        :rules&#x3D;&quot;rules&quot;</span><br><span class="line">        ref&#x3D;&quot;ruleForm&quot;</span><br><span class="line">        label-position&#x3D;&quot;left&quot;</span><br><span class="line">        label-width&#x3D;&quot;80px&quot;</span><br><span class="line">        class&#x3D;&quot;demo-ruleForm&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;用户名&quot; prop&#x3D;&quot;uname&quot;&gt;</span><br><span class="line">          &lt;el-input v-model&#x3D;&quot;ruleForm.uname&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;密码&quot; prop&#x3D;&quot;pass&quot;&gt;</span><br><span class="line">          &lt;el-input</span><br><span class="line">            type&#x3D;&quot;password&quot;</span><br><span class="line">            v-model&#x3D;&quot;ruleForm.pass&quot;</span><br><span class="line">            autocomplete&#x3D;&quot;off&quot;</span><br><span class="line">          &gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">        &lt;el-form-item label&#x3D;&quot;确认密码&quot; prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">          &lt;el-input</span><br><span class="line">            type&#x3D;&quot;password&quot;</span><br><span class="line">            v-model&#x3D;&quot;ruleForm.password&quot;</span><br><span class="line">            autocomplete&#x3D;&quot;off&quot;</span><br><span class="line">          &gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">        &lt;&#x2F;el-form-item&gt;</span><br><span class="line">      &lt;&#x2F;el-form&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;btnGroup&quot;&gt;</span><br><span class="line">        &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;submitForm(&#39;ruleForm&#39;)&quot;  v-loading&#x3D;&quot;loading&quot;</span><br><span class="line">          &gt;提交&lt;&#x2F;el-button</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;resetForm(&#39;ruleForm&#39;)&quot;&gt;重置&lt;&#x2F;el-button&gt;</span><br><span class="line">        &lt;el-button @click&#x3D;&quot;goBack&quot;&gt;返回&lt;&#x2F;el-button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;el-card&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    var validatePass &#x3D; (rule, value, callback) &#x3D;&gt; &#123;</span><br><span class="line">      if (value &#x3D;&#x3D;&#x3D; &quot;&quot;) &#123;</span><br><span class="line">        callback(new Error(&quot;请输入密码&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (this.ruleForm.checkPass !&#x3D;&#x3D; &quot;&quot;) &#123;</span><br><span class="line">          this.$refs.ruleForm.validateField(&quot;checkPass&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var validatePass2 &#x3D; (rule, value, callback) &#x3D;&gt; &#123;</span><br><span class="line">      if (value &#x3D;&#x3D;&#x3D; &quot;&quot;) &#123;</span><br><span class="line">        callback(new Error(&quot;请再次输入密码&quot;));</span><br><span class="line">      &#125; else if (value !&#x3D;&#x3D; this.ruleForm.pass) &#123;</span><br><span class="line">        callback(new Error(&quot;两次输入密码不一致!&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      ruleForm: &#123;</span><br><span class="line">        uname: &quot;&quot;,</span><br><span class="line">        pass: &quot;&quot;,</span><br><span class="line">        password: &quot;&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        uname: [</span><br><span class="line">          &#123; required: true, message: &quot;用户名不能为空！&quot;, trigger: &quot;blur&quot; &#125;,</span><br><span class="line">        ],</span><br><span class="line">        pass: [&#123; required: true, validator: validatePass, trigger: &quot;blur&quot; &#125;],</span><br><span class="line">        password: [</span><br><span class="line">          &#123; required: true, validator: validatePass2, trigger: &quot;blur&quot; &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      loading: false</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].validate((valid) &#x3D;&gt; &#123;</span><br><span class="line">        this.loading &#x3D; true;  &#x2F;&#x2F; 提交按钮显示加载动画</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          let _this &#x3D; this;</span><br><span class="line">          this.axios(&#123;     &#x2F;&#x2F; axios 向后端发起请求</span><br><span class="line">            url: &quot;&#x2F;api&#x2F;user&#x2F;register&quot;,  &#x2F;&#x2F; 请求地址</span><br><span class="line">            method: &quot;post&quot;,             &#x2F;&#x2F; 请求方法</span><br><span class="line">            headers: &#123;                  &#x2F;&#x2F; 请求头</span><br><span class="line">              &quot;Content-Type&quot;: &quot;application&#x2F;json&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            data: &#123; &#x2F;&#x2F; 请求参数，为 data，与登录的 params 不太一样</span><br><span class="line">              uname: _this.ruleForm.uname,</span><br><span class="line">              password: _this.ruleForm.password,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;).then((res) &#x3D;&gt; &#123; &#x2F;&#x2F; 当收到后端的响应时执行该括号内的代码，res 为响应信息，也就是后端返回的信息</span><br><span class="line">            if (res.data.code &#x3D;&#x3D;&#x3D; &#39;0&#39;) &#123;  &#x2F;&#x2F; 当响应的编码为 0 时，说明注册成功</span><br><span class="line">              &#x2F;&#x2F; 显示后端响应的成功信息</span><br><span class="line">              this.$message(&#123;</span><br><span class="line">                message: res.data.msg,</span><br><span class="line">                type: &quot;success&quot;,</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;else&#123;  &#x2F;&#x2F; 当响应的编码不为 0 时，说明注册失败</span><br><span class="line">              &#x2F;&#x2F; 显示后端响应的失败信息</span><br><span class="line">              this.$message(&#123;</span><br><span class="line">                message: res.data.msg,</span><br><span class="line">                type: &quot;warning&quot;,</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 不管响应成功还是失败，收到后端响应的消息后就不再让登录按钮显示加载动画了</span><br><span class="line">            _this.loading &#x3D; false;</span><br><span class="line">            console.log(res);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; 如果账号或密码有一个没填，就直接提示必填，不向后端请求</span><br><span class="line">          console.log(&quot;error submit!!&quot;);</span><br><span class="line">          this.loading &#x3D; false;</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    resetForm(formName) &#123;</span><br><span class="line">      this.$refs[formName].resetFields();</span><br><span class="line">    &#125;,</span><br><span class="line">    goBack() &#123;</span><br><span class="line">      this.$router.go(-1);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&#x2F;* 设置登录面板居中，宽度为400px *&#x2F;</span><br><span class="line">.box-card &#123;</span><br><span class="line">  margin: auto auto;</span><br><span class="line">  width: 400px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 设置登录面板中的表单居中 *&#x2F;</span><br><span class="line">.login-from &#123;</span><br><span class="line">  margin: auto auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>写完注册也测试一下是否能注册成功</p>
<p><img src="/posts/78e35d03/image-20220205173334284.png" alt="注册测试"></p>
<h3 id="完善首页显示用户信息功能"><a href="#完善首页显示用户信息功能" class="headerlink" title="完善首页显示用户信息功能"></a>完善首页显示用户信息功能</h3><p>这个功能主要就是把登录成功时存储到 sessionStorage 中的用户信息取出来，再显示到首页页面上。主要就是图中绿框部分发生了变化。</p>
<p><img src="/posts/78e35d03/image-20220205173856007.png" alt="首页代码差异"></p>
<p><strong>完善后的首页<code>src/views/home/Home.vue</code>代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;欢迎&#123;&#123; user.uname &#125;&#125;！您的 uid 为&#123;&#123; user.uid &#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;el-button @click&#x3D;&quot;logout&quot;&gt; 登出 &lt;&#x2F;el-button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        uname: &quot;&quot;,</span><br><span class="line">        uid: null,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    logout()&#123;</span><br><span class="line">      &#x2F;&#x2F; 移除本地用户登录信息</span><br><span class="line">      sessionStorage.removeItem(&#39;userInfo&#39;);</span><br><span class="line">      &#x2F;&#x2F; 跳转页面到登录页</span><br><span class="line">      this.$router.push(&#39;&#x2F;login&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    if (sessionStorage.getItem(&#39;userInfo&#39;)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 将用户信息存储到sessionStorage中</span><br><span class="line">      this.user &#x3D; JSON.parse(sessionStorage.getItem(&#39;userInfo&#39;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>测试首页功能</p>
<p><img src="/posts/78e35d03/image-20220205174250415.png" alt="测试首页功能"></p>
<p>到这，整个项目看起来都完工了，可以注册、登录，登录完能跳转到首页，首页也能正常显示用户信息。但其实还有个隐藏的问题，如果我们没有登录，直接在浏览器的地址栏中输入<code>localhost:8080/home</code>，回车后我们会发现我们能直接进入到首页中，而且首页没法正常显示用户的信息。这也正常，没有登录为啥会有用户信息，但按道理没有登录我们不应该让用户可以进入到首页才对，这就涉及到一个新的概念，就是<strong>导航守卫</strong>，具体的我们在下面详细介绍。</p>
<h3 id="配置导航守卫"><a href="#配置导航守卫" class="headerlink" title="配置导航守卫"></a>配置导航守卫</h3><blockquote>
<p>导航守卫，正如其名，它是由 <strong>vue-router</strong> 插件提供的一个功能，在路由发生改变时，也就是地址栏中的地址发生变化时，导航守卫会把页面的“跳转”拦截下来，并做一些处理。在我们刚刚说到的没有登录也能进入首页的问题中，我们就能利用这个功能，在用户想直接通过浏览器地址栏进入首页时，进行拦截，判断这个用户是否已经登录了，如果登录的了的话 sessionStorage 中应该会存有用户的信息，如果找不到用户的登录信息，那就把用户强制导航到登录页面，也就守卫住了进入首页的这个导航。</p>
</blockquote>
<p>官方介绍：<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">导航守卫 | Vue Router (vuejs.org)</a></p>
<p>在本项目中，我们使用的是<strong>全局前置守卫</strong>也就是在页面“跳转”前进行拦截</p>
<p>实现导航守卫的功能只需要在<code>src/router/index.js</code>路由配置中添加一个全局前置守卫的方法就行了，具体见图红框部分</p>
<p><img src="/posts/78e35d03/image-20220205180346293.png" alt="添加全局前置守卫"></p>
<p>修改后的<code>src/router/index.js</code>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此文件专门负责项目的路由</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;../views/login/Login&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Register <span class="keyword">from</span> <span class="string">&#x27;../views/register/Register&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../views/home/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">&quot;element-ui&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,    <span class="comment">// 路由模式，该模式不会在地址中显示井号#</span></span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/&#x27;</span>,          <span class="comment">// 路径</span></span><br><span class="line">            redirect: <span class="string">&#x27;/login&#x27;</span>  <span class="comment">// 重定向</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/login&#x27;</span>,     <span class="comment">// 路径</span></span><br><span class="line">            component: Login    <span class="comment">// 跳转到的组件</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/register&#x27;</span>,     <span class="comment">// 路径</span></span><br><span class="line">            component: Register    <span class="comment">// 跳转到的组件</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">&#x27;/home&#x27;</span>,     <span class="comment">// 路径</span></span><br><span class="line">            component: Home    <span class="comment">// 跳转到的组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导航守卫，前置处理</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> isAuthenticated = !!sessionStorage.getItem(<span class="string">&#x27;userInfo&#x27;</span>)</span><br><span class="line">    <span class="comment">// 如果路由要跳转到除了登录和注册的界面的话就判断是否已经登录，如果没有登录就强制跳到登录界面</span></span><br><span class="line">    <span class="keyword">if</span> (to.path !== <span class="string">&#x27;/login&#x27;</span> &amp;&amp; to.path !== <span class="string">&#x27;/register&#x27;</span> &amp;&amp; !isAuthenticated) &#123;</span><br><span class="line">        next(&#123; <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span> &#125;)</span><br><span class="line">        Message(&#123;</span><br><span class="line">            message: <span class="string">&#x27;请先登录！&#x27;</span>,</span><br><span class="line">            type: <span class="string">&quot;warning&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>

<p>写完后可以测试一下不登录直接在地址栏中输入<code>http://localhost:8080/home</code>能不能被拦截再跳回登录页面</p>
<p>如果所有功能测试都正常的话，那就芜湖~起飞了哈哈哈</p>
<p>非常感谢你能看到这里，希望本文对你能有所帮助~</p>
<p>教程中可能有很多不准确的地方，欢迎在下方通过评论，我一定会及时回复的。</p>
<h2 id="项目源代码"><a href="#项目源代码" class="headerlink" title="项目源代码"></a>项目源代码</h2><ul>
<li>Vue 前端：<a href="https://github.com/MakerHu/vue-login-demo">MakerHu/vue-login-demo (github.com)</a></li>
<li>SpringBoot 后端：<a href="https://github.com/MakerHu/springboot-login-demo">MakerHu/springboot-login-demo (github.com)</a></li>
</ul>
<h2 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h2><ul>
<li>后端教程：<a href="https://www.makerhu.com/posts/5b2ca0db/">快速上手SpringBoot项目（登录注册保姆级教程） | MakerHu 的博客</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>野生教程</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>前后端分离</tag>
        <tag>SpringBoot</tag>
        <tag>Vue+SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用手册</title>
    <url>/posts/6600e9a1/</url>
    <content><![CDATA[<blockquote>
<p>本教程整理了hexo写博客的一些常用命令以及常用方法，供大家参考，不定期更新</p>
</blockquote>
<span id="more"></span>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><p>清理数据<br><code>hexo clean</code></p>
</li>
<li><p>新建博客<br><code>hexo new &quot;My New Post&quot;</code></p>
</li>
<li><p>启动服务<br><code>hexo server</code> 或 <code>hexo s</code></p>
</li>
<li><p>生成静态文件<br><code>hexo generate</code> 或  <code>hexo g</code></p>
</li>
<li><p>部署到远端<br><code>hexo deploy</code> 或 <code>hexo d</code></p>
</li>
<li><p>创建新的页面<br><code>hexo new page &quot;pagename&quot;</code></p>
</li>
<li><p>日常备份及部署过程</p>
<p>写完博客后首先是在本地检查博客效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看效果<br>确认无误后，再次清空、备份再编译部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Backup&quot;</span></span><br><span class="line">git push -u origin main</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><h3 id="文章配置"><a href="#文章配置" class="headerlink" title="文章配置"></a>文章配置</h3><p>在markdown文章的头部可配置以下属性</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 首页文章显示的标题</span><br><span class="line">date: 创建时间</span><br><span class="line">updated: 更新时间</span><br><span class="line">comments: true/false (是否开启评论)</span><br><span class="line">tags: 标签（不适用于分页）无层级关系，各标签并列</span><br><span class="line"><span class="bullet">-</span> 标签一</span><br><span class="line"><span class="bullet">-</span> 标签二</span><br><span class="line">categories: 分类（不适用于分页）有层级关系，下述例子表示本文章归类于学习大类下的微积分下的第二章</span><br><span class="line"><span class="bullet">-</span> 学习</span><br><span class="line"><span class="bullet">-</span> 微积分</span><br><span class="line"><span class="bullet">-</span> 第二章</span><br><span class="line">---</span><br></pre></td></tr></table></figure>



<h3 id="首页显示文章摘要"><a href="#首页显示文章摘要" class="headerlink" title="首页显示文章摘要"></a>首页显示文章摘要</h3><ul>
<li>方法1：使用<code>&lt;!-- more --&gt;</code>对文章进行截断，在这之前的内容会放到摘要里</li>
<li>方法2：在markdown文章的顶部加上<code>description</code>关键字<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">categories: </span><br><span class="line">tags: </span><br><span class="line">description: 你对文章的整体介绍等</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="界面修改"><a href="#界面修改" class="headerlink" title="界面修改"></a>界面修改</h2><h3 id="配置博文阅读目录"><a href="#配置博文阅读目录" class="headerlink" title="配置博文阅读目录"></a>配置博文阅读目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  # 如果为true则自动添加序号到目录中</span><br><span class="line">  number: true</span><br><span class="line">  # 如果为true目录过长部分会换行显示</span><br><span class="line">  wrap: true</span><br><span class="line">  # 如果为true目录会保持全展开，而不是只展开激活部分</span><br><span class="line">  expand_all: true</span><br><span class="line">  # 目录的最大层级数</span><br><span class="line">  max_depth: 6</span><br></pre></td></tr></table></figure>

<h2 id="hexo备份与恢复"><a href="#hexo备份与恢复" class="headerlink" title="hexo备份与恢复"></a>hexo备份与恢复</h2><p>由于hexo在将博客部署到远程仓库时是将编译后的文件部署上去的，而源文件还是保留在本地（最核心的是文章的.md文件），因而可能存在源文件丢失的风险，如：电脑丢失，文件丢失等。因此做好源文件的备份是个良好的习惯，如果将源文件备份到github，还有利于我们在其他电脑中恢复对博客的管理。</p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><h4 id="在GitHub中创建仓库"><a href="#在GitHub中创建仓库" class="headerlink" title="在GitHub中创建仓库"></a>在GitHub中创建仓库</h4><p><img src="/posts/6600e9a1/20210507111530.png"></p>
<img src="/posts/6600e9a1/20210507111923.png" style="zoom: 67%;">

<h4 id="将本地的博客源文件上传到GitHub"><a href="#将本地的博客源文件上传到GitHub" class="headerlink" title="将本地的博客源文件上传到GitHub"></a>将本地的博客源文件上传到GitHub</h4><p><strong>注意：在执行下列命令前先将你博客根目录下themes/&lt;主题名&gt;/下的.gitignore文件删了！</strong><br>原因是git文件不能嵌套，否则会报错（忘删导致报错解决方案：<a href="#%E4%B8%BB%E9%A2%98%E4%B8%AD%E7%9A%84.git%E6%96%87%E4%BB%B6%E6%9C%AA%E5%88%A0%E5%B0%B1%E4%B8%8A%E4%BC%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">主题中的.git文件未删就上传远程仓库</a>）</p>
<p>在你的博客源文件根目录下git bash</p>
<img src="/posts/6600e9a1/20210507113349.png" style="zoom:80%;">

<p>分别执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# MyHexoBlogBackup&quot;</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/yourname/MyBlogBackup.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p>若出现报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/yourname/MyBlogBackup.git/&#x27;</span>: Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure>
<p>请见解决方案：<a href="#git%E6%8A%A5%E9%94%99Failed-to-connect-to-github">git报错Failed to connect to github</a></p>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>默认前提：电脑中已安装git 、nodejs、hexo</p>
<h4 id="克隆博客源文件"><a href="#克隆博客源文件" class="headerlink" title="克隆博客源文件"></a>克隆博客源文件</h4><p>克隆项目到本地<br><code>git clone https://github.com/yourname/MyBlogBackup.git</code></p>
<p>若还是出现报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/yourname/MyBlogBackup.git/&#x27;</span>: Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure>
<p>请见解决方案<a href="#git%E6%8A%A5%E9%94%99Failed-to-connect-to-github">git报错Failed to connect to github</a></p>
<h4 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h4><p>进入到博客源文件的根目录下git bash或cmd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli</span><br><span class="line">npm install <span class="comment"># 安装依赖</span></span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>接下来就是熟悉的命令了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h4 id="日常的备份过程"><a href="#日常的备份过程" class="headerlink" title="日常的备份过程"></a>日常的备份过程</h4><p>写完博客后首先是在本地检查博客效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看效果<br>确认无误后，再次清空、备份再编译部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Backup&quot;</span></span><br><span class="line">git push -u origin main</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2 id="博客链接永久化"><a href="#博客链接永久化" class="headerlink" title="博客链接永久化"></a>博客链接永久化</h2><p>hexo的默认永久链接是在 _config.yml 里配置的，其生成规则是<br><code>permalink: :year/:month/:day/:title/</code><br>效果是<code>https://makerhu.github.io/2021/05/05/hexo使用手册/</code></p>
<p>这种方式有两个很大的<strong>缺点</strong>：</p>
<ul>
<li><p>一是路径中带中文名，复制分享链接时会转换成很长的字符串，不利于分享，以前面展示的效果链接为例，复制链接后的效果是<br><code>https://makerhu.github.io/2021/05/05/hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</code><br>vs<br><code>https://makerhu.github.io/2021/05/05/hexo使用手册/</code></p>
</li>
<li><p>二是修改博客的文件名时文章的url也会发生变化，这样如果有人收藏了你的文章地址，你改了文章名称后他/她就访问不了了</p>
</li>
</ul>
<p>因此，博客链接永久化有着重要的意义<br><strong>解决方案</strong>：使用hexo-abbrlink 插件</p>
<ul>
<li>安装<br><code>npm install hexo-abbrlink --save</code></li>
<li>配置<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可选 permalink: abbrlink 短链接模式</span></span><br><span class="line"><span class="comment"># permalink: posts/:abbrlink.html</span></span><br><span class="line"><span class="comment"># permalink: posts/:abbrlink/</span></span><br><span class="line">permalink: :abbrlink/ <span class="comment">#文章的永久链接</span></span><br><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  <span class="comment">#算法: crc16(default) and crc32</span></span><br><span class="line">  rep: hex    <span class="comment">#进制: dec(default) and hex</span></span><br></pre></td></tr></table></figure></li>
<li>hexo命令一条龙<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s	<span class="comment"># 检查效果正常后即可部署</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
</ul>
<p>配置完成后博客的markdown文件顶部的Front-matter中会添加一个属性<code>abbrlink:</code>后面跟着的就是固定的链接地址</p>
<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="无法将项目部署到远端"><a href="#无法将项目部署到远端" class="headerlink" title="无法将项目部署到远端"></a>无法将项目部署到远端</h3><ol>
<li>问题描述<br><code>hexo d</code> 时经常报错，要试好几次才能成功<br>报错：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">INFO  Copying files from extend dirs...</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;MakerHu&#x2F;makerhu.github.io.git&#x2F;&#39;: Failed to connect to github.com port 443: Timed out</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (E:\study\self_study\myblog\node_modules\_hexo-util@2.4.0@hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at ChildProcess.cp.emit (E:\study\self_study\myblog\node_modules\_cross-spawn@7.0.3@cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br></pre></td></tr></table></figure></li>
<li>解决方案<ul>
<li>取消git代理<br><code>git config --global --unset http.proxy</code></li>
<li>host文件添加最新的github的IP列表<br>ip列表可到这个博文获取 <a href="http://blog.yoqi.me/lyq/16489.html">github被墙最新hosts-每日更新 | 天问博客 (yoqi.me)</a></li>
</ul>
</li>
</ol>
<h3 id="git报错Failed-to-connect-to-github"><a href="#git报错Failed-to-connect-to-github" class="headerlink" title="git报错Failed to connect to github"></a>git报错Failed to connect to github</h3><ol>
<li><p>报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/yourname/MyBlogBackup.git/&#x27;</span>: Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure></li>
<li><p>解决方案<br>方法1：</p>
<ul>
<li>查看git配置<br><code>git config --global -l</code></li>
<li>检查环境变量<br><code>env|grep -i proxy</code></li>
</ul>
<p>方法2：</p>
<ul>
<li>分别执行以下命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="主题中的-git文件未删就上传远程仓库"><a href="#主题中的-git文件未删就上传远程仓库" class="headerlink" title="主题中的.git文件未删就上传远程仓库"></a>主题中的.git文件未删就上传远程仓库</h3><p>由于.git文件不能嵌套，因此需要删除themes/&lt;主题名&gt;/下的.git文件才能上传</p>
<ul>
<li>删除themes/&lt;主题名&gt;/下的.git文件</li>
<li>从暂存区删除该文件夹<br><code>git rm --cache themes/next</code></li>
<li>重新添加到git中<br><code>git add .</code></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></li>
<li><a href="http://blog.yoqi.me/lyq/16489.html">github被墙最新hosts-每日更新 | 天问博客 (yoqi.me)</a></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>野生教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>hexo备份</tag>
        <tag>hexo恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式之动态代理</title>
    <url>/posts/39d16fd4/</url>
    <content><![CDATA[<blockquote>
<p>代理模式简单来说就是一个对象 A 代替另一个对象 B 去完成对象 B 本该自己做的事，在代理的过程中，对象 A 可以对被代理的事情进行<strong>加强</strong>。静态代理与动态代理的最大区别是静态代理是程序员在代码中实现了代理类，而动态代理则是在程序运行时动态地生成代理类。</p>
</blockquote>
<span id="more"></span>

<p>在看动态代理之前，我们首先要理解什么是静态代理，如果还不明白什么是静态代理可以先去看看我之前的文章<a href="https://www.makerhu.com/posts/3c271a1b/">代理模式之静态代理</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>假设我们已经实现了一个项目的很多业务逻辑代码，现在客户要求我们在所有的业务逻辑的执行前后都添加日志记录，这时候我们应该怎么办？</p>
<ul>
<li><input disabled type="checkbox"> 在每个业务逻辑实现的方法前后添加日志代码——太麻烦且会修改源代码，不符合开闭原则</li>
<li><input disabled type="checkbox"> 使用静态代理——在实现代理类时需要实现接口中的所有方法，并在方法中都添加日志，同样很麻烦，优点是不用修改源代码</li>
<li><input checked disabled type="checkbox"> 使用动态代理——在程序运行时自动实现代理类</li>
</ul>
<p>那么动态代理是如何实现的呢？我们接着往下看。</p>
<h2 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h2><ul>
<li><strong>代理接口：</strong> 要被代理的行为在这个接口中被声明，委托类与代理类都实现了这个接口</li>
<li><strong>委托类：</strong> 在这里是指实现业务逻辑的那些类</li>
<li><strong>代理类：</strong> 代理委托类，并可增强委托类方法的功能，在这里指在执行委托类的方法时为其添加日志</li>
</ul>
<p><img src="/posts/39d16fd4/20210919170232.png" alt="关系图"></p>
<p>这三个角色及其作用与静态代理是完全一致的，差别就在于<strong>动态代理中的代理类并不是程序员写好在程序中的而是在运行时自动生成的</strong>。</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>明白了代理模式的结构与关系后，我们就不难理解动态代理实现的步骤了。我们知道动态代理是在运行时根据代理接口和委托类生成代理类，那么我们首先肯定得先写好代理接口和委托类，接着我们需要再写一个“工具”，在运行时这个工具能获取到代理接口和委托类的信息，并根据这些信息自动生成代理类，最后用户使用生成的代理类创建代理对象，这样用户就能通过代理对象调用方法了。</p>
<p>那么，我们要实现的这个“工具”中都干了什么呢？</p>
<p><img src="/posts/39d16fd4/20210920112305.png" alt="伪代码过程"></p>
<ol>
<li><p>实现一个名为 InvocationHandler 的接口的类，这个接口中只有一个方法需要实现，叫做 invoke，而 invoke 方法就是对委托类中方法的代理及增强</p>
</li>
<li><p>通过代理接口生成代理类，代理类中包含一个成员对象，它的类型是第1步提到的 InvocationHandler。代理类中的方法是根据接口中声明的方法生成的，在每个方法中都会调用到 第1步中的方法 invoke。代理类中还会生成一个构造器，它的参数类型是 InvocationHandler，用于初始化代理类中的那个成员变量。</p>
<blockquote>
<p>Each proxy instance has an associated invocation handler object, the one that was passed to its constructor.</p>
<p>——<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html">Java官方文档</a>中对Dynamic Proxy Classes的描述</p>
</blockquote>
</li>
<li><p>获取调用第2步生成的以 InvocationHandler 为参数的代理类的构造器</p>
</li>
<li><p>调用第3步获取的代理类的构造器，传入第1步实现的 InvocationHandler 作为参数，最后返回实例化后的代理对象</p>
</li>
</ol>
<p><a href="https://docs.oracle.com/javase/8/docs/api/">Java官方文档</a>中给了我们两个实现动态代理的示例：</p>
<p>To create a proxy for some interface Foo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(...);</span><br><span class="line">Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);</span><br><span class="line">Foo f = (Foo) proxyClass.getConstructor(InvocationHandler.class).newInstance(handler);</span><br></pre></td></tr></table></figure>

<p>or more simply:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),</span><br><span class="line">                                     <span class="keyword">new</span> Class&lt;?&gt;[] &#123; Foo.class &#125;,</span><br><span class="line">                                     handler);</span><br></pre></td></tr></table></figure>

<p>这两段示例代码与上面说的 4 个步骤是一样的，第二个示例其实就是将第一个示例的实现方式封装在了方法里，接下来的代码实现中，我们将分别用这两种方式实现动态代理。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="背景回顾"><a href="#背景回顾" class="headerlink" title="背景回顾"></a>背景回顾</h4><p>回忆一下文章开始提到的背景，项目中已经实现了业务逻辑的代码了，该业务逻辑的代码是实现了某个业务接口。我们对其进行分析抽象，业务接口也就是我们的在代理模式中提到的三个角色中的代理接口，而业务实现代码就是委托类，现在我们要做的事情是在委托类中的所有方法中添加执行日志。</p>
<p>业务接口（代理接口）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务实现代码（委托类）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImpl</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加了新的对象：&quot;</span> + obj);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态代理：</strong></p>
<p>注：这部分代码可能需要有一些反射相关的知识才能帮助我们更好的理解代码</p>
<h4 id="方法一：深入"><a href="#方法一：深入" class="headerlink" title="方法一：深入"></a>方法一：深入</h4><ol>
<li><p>创建一个类实现 InvocationHandler 接口</p>
<p>这个类的作用就是实现代理方法去代理委托类中的方法，并对其进行增强。而这个代理的方法就是 InvocationHandler 接口中声明的 invoke 方法。我们可以理解为 invoke 方法就是一个模板，它可以为委托类中的方法都套上一个壳，作为代理对象中的一个方法，也就是委托类中被代理后的方法，程序运行时能根据这个模板生成委托类中要被代理的方法。</p>
<p><strong>MyInvocationHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object target;  <span class="comment">// 委托对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法可以理解为被代理的方法的一个模板，程序运行时能根据这个模板生成委托类中要被代理的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 动态代理中运行时生成的代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 被代理方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值的类型与被代理方法的返回值类型有关</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        System.out.println(<span class="string">&quot;[日志]执行方法 &quot;</span> + method.getName() + <span class="string">&quot; 前&quot;</span>); <span class="comment">// 方法增强</span></span><br><span class="line">        result = method.invoke(target, args);                          <span class="comment">// 执行被代理的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[日志]执行方法 &quot;</span> + method.getName() + <span class="string">&quot; 后&quot;</span>); <span class="comment">// 方法增强</span></span><br><span class="line">        <span class="keyword">return</span> result;                                                 <span class="comment">// 代理方法的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invoke 方法中的返回值：</p>
<ul>
<li>当代理接口声明的返回值是基本数据类型，那么 invoke 返回的值必须是对应的包装类的实例</li>
<li>如果 invoke 返回的值为 null 且接口方法的返回类型为基本数据类型，则代理实例上的方法调用将抛出 NullPointerException</li>
<li>如果 invoke 返回的值与接口中方法声明的返回类型不兼容，则代理实例将抛出 ClassCastException。</li>
</ul>
</li>
<li><p>通过代理接口生成代理类</p>
</li>
<li><p>获取调用第2步生成的以 InvocationHandler 为参数的代理类的构造器</p>
</li>
<li><p>调用第3步获取的代理类的构造器，传入第1步实现的 InvocationHandler 作为参数，最后返回实例化后的代理对象</p>
<p>2、3、4步代码就一起展示了：</p>
<p><strong>Main.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        ServiceImpl serviceImpl = <span class="keyword">new</span> ServiceImpl();    <span class="comment">// 委托实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/***** 第1步 *****/</span></span><br><span class="line">        InvocationHandler myInvocationHandler = <span class="keyword">new</span> MyInvocationHandler(serviceImpl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***** 第2步 *****</span></span><br><span class="line"><span class="comment">         * 通过类加载器与代理接口生成代理类 proxyClass</span></span><br><span class="line"><span class="comment">         * 其中类加载器 serviceImpl.getClass().getClassLoader()</span></span><br><span class="line"><span class="comment">         * 代理接口 serviceImpl.getClass().getInterfaces()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class proxyClass = Proxy.getProxyClass(serviceImpl.getClass().getClassLoader(),serviceImpl.getClass().getInterfaces());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***** 第3步 *****</span></span><br><span class="line"><span class="comment">         * 获取代理类的指定构造器（以 InvocationHandler 为参数的构造器）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Constructor proxyConstructor = proxyClass.getConstructor(InvocationHandler.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***** 第4步 *****</span></span><br><span class="line"><span class="comment">         * 通过构造器实例化代理对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Service proxyInstance = (Service) proxyConstructor.newInstance(myInvocationHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理方法，测试方法增强并测试返回值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;返回值：&quot;</span> + proxyInstance.add(<span class="string">&quot;MakerHu&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[日志]执行方法 add 前</span><br><span class="line">添加了新的对象：MakerHu</span><br><span class="line">[日志]执行方法 add 后</span><br><span class="line">返回值：true</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="方法二：浅出"><a href="#方法二：浅出" class="headerlink" title="方法二：浅出"></a>方法二：浅出</h4><p>除了上述的这种方式实现动态代理，<a href="https://docs.oracle.com/javase/8/docs/api/">Java官方文档</a>中还给了我们另一个简单的实现方式的示例（在前面也提到了）：</p>
<p>or more simply:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),</span><br><span class="line">                                     <span class="keyword">new</span> Class&lt;?&gt;[] &#123; Foo.class &#125;,</span><br><span class="line">                                     handler);</span><br></pre></td></tr></table></figure>

<p>这种方法就是将方法一中的步骤全都放到了方法 newProxyInstance 中帮我们实现好了，因此我们只要直接调用就能直接获取到代理对象了。这种方法其他部分的代码都不用变，只要修改 Main.java 为如下：</p>
<p><strong>Main.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceImpl serviceImpl = <span class="keyword">new</span> ServiceImpl();    <span class="comment">// 委托实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/***** 第1步 *****</span></span><br><span class="line"><span class="comment">         * 创建 InvocationHandler 的实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        InvocationHandler myInvocationHandler = <span class="keyword">new</span> MyInvocationHandler(serviceImpl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第 2、3、4 步整合为了一个方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Service proxyInstance = (Service) Proxy.newProxyInstance(serviceImpl.getClass().getClassLoader(),</span><br><span class="line">                serviceImpl.getClass().getInterfaces(),</span><br><span class="line">                myInvocationHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理方法，测试方法增强并测试返回值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;返回值：&quot;</span> + proxyInstance.add(<span class="string">&quot;MakerHu&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="方法三：完善"><a href="#方法三：完善" class="headerlink" title="方法三：完善"></a>方法三：完善</h4><p>为了更方便使用，我们还能将方法二中的获取代理实例的代码作为静态方法整合到 MyInvocationHandler 中去，<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html">Java官方文档</a>中也给我们了一个更加完整的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">bar</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> BazException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooImpl</span> <span class="keyword">implements</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">bar</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> BazException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugProxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.newProxyInstance(</span><br><span class="line">            obj.getClass().getClassLoader(),</span><br><span class="line">            obj.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> DebugProxy(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DebugProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method m, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before method &quot;</span> + m.getName());</span><br><span class="line">            result = m.invoke(obj, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;unexpected invocation exception: &quot;</span> +</span><br><span class="line">                                       e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;after method &quot;</span> + m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取代理实例时只需要：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo foo = (Foo) DebugProxy.newInstance(<span class="keyword">new</span> FooImpl());</span><br><span class="line">foo.bar(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>仔细观察我们就能发现，这种方法与第二种方法没有本质区别，只是将第二种方法中的 Proxy.newProxyInstance 方法移动到了实现了 InvocationHandler 接口的类中作为一个静态方法被调用。</p>
<p>用这种方法实现我们的例子：</p>
<p><strong>MyInvocationHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 与方法二的差别：静态方法调用 **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">new</span> MyInvocationHandler(target));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        System.out.println(<span class="string">&quot;[日志]执行方法 &quot;</span> + method.getName() + <span class="string">&quot; 前&quot;</span>);</span><br><span class="line">        result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;[日志]执行方法 &quot;</span> + method.getName() + <span class="string">&quot; 后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Main.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceImpl student = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">        Service proxyInstance = (Service) MyInvocationHandler.newInstance(student);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法返回值：&quot;</span> + proxyInstance.add(<span class="string">&quot;MakerHu&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态代理与静态代理的区别就是静态代理的代理类是写在程序中的，而动态代理的代理类是在程序运行时借助 InvocationHandler，Proxy.getProxyClass 等生成的，动态代理由于其实现方式更加灵活，因此可以同时代理不同接口的行为而不用修改代码。以上述背景为例，如果还有一部分业务逻辑实现了接口 Service02.java，领导要求我们也要为这部分业务方法添加日志，那么使用动态代理并不需要更改代码，只要将实现了 Service02 接口的对象传入方法中即可，而静态代理则需要再写一个代理类来完成同样的任务，使代码更加冗余了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html">Dynamic Proxy Classes (oracle.com)</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/">Proxy (Java Platform SE 8 ) (oracle.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
        <tag>proxy pattern</tag>
        <tag>动态代理</tag>
        <tag>dynamic proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式之静态代理</title>
    <url>/posts/3c271a1b/</url>
    <content><![CDATA[<blockquote>
<p>代理模式我们可以从字面上去理解它的涵义，代理就是<strong>代替</strong>某个事物去<strong>处理</strong>事情，代理在代替处理事情的时候可能还会添加一些它的补充行为。以生活中申请留学的代理机构为例，代理机构代替你去申请国外高校，除了“申请高校”这件事外，它还在申请之前帮你“查询高校信息”，并在申请成功之后向你“要代理费”。接下来我就以申请留学为例简单实现一个静态代理的例子。</p>
</blockquote>
<span id="more"></span>

<h2 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h2><ul>
<li><p><strong>要代理的事情</strong>（一般是一个接口）：申请留学这件事（StudyAbroad）</p>
</li>
<li><p><strong>委托人</strong>：学生（Student）</p>
</li>
<li><p><strong>代理人</strong>：留学申请机构（StudyAbroadAgent）</p>
</li>
</ul>
<p>他们的<strong>关系</strong>：留学申请机构代理学生去申请留学</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="StudyAbroad-java"><a href="#StudyAbroad-java" class="headerlink" title="StudyAbroad.java"></a>StudyAbroad.java</h3><p>要代理的事：申请留学，就是一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要代理的事情：申请留学这件事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudyAbroad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyForStudyAbroad</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Student-java"><a href="#Student-java" class="headerlink" title="Student.java"></a>Student.java</h3><p>学生要出国留学，也是真正要做代理的事的对象，他实现申请留学这件事的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">StudyAbroad</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyForStudyAbroad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;申请留学成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="StudyAbroadAgent-java"><a href="#StudyAbroadAgent-java" class="headerlink" title="StudyAbroadAgent.java"></a>StudyAbroadAgent.java</h3><p>代理机构同样也实现申请留学这件事的接口，但他在实现时调用了委托人的申请留学方法，也就是<strong>替</strong>委托人申请留学。并且在代理申请留学之前还帮助学生查询了高校信息，替学生省事了，但是代理完后要交钱😂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理人：留学申请机构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyAbroadAgent</span> <span class="keyword">implements</span> <span class="title">StudyAbroad</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托人</span></span><br><span class="line">    <span class="keyword">private</span> StudyAbroad studyAbroad;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudyAbroadAgent</span><span class="params">(StudyAbroad studyAbroad)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studyAbroad = studyAbroad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyForStudyAbroad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        studyAbroad.applyForStudyAbroad();  <span class="comment">// 替委托人完成要代理的事</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请之前帮你查询国外高校信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询国外高校信息。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请之后向你要代理费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收取代理费。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Main-java"><a href="#Main-java" class="headerlink" title="Main.java"></a>Main.java</h3><p>主函数，请代理机构帮某个学生(MakerHu)申请留学。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">&quot;MakerHu&quot;</span>);</span><br><span class="line">        StudyAbroadAgent studyAbroadAgent = <span class="keyword">new</span> StudyAbroadAgent(student);</span><br><span class="line">        studyAbroadAgent.applyForStudyAbroad();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>运行结果</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查询国外高校信息。</span><br><span class="line">MakerHu申请留学成功！</span><br><span class="line">收取代理费。</span><br></pre></td></tr></table></figure>



<h2 id="静态代理模式有啥用呢"><a href="#静态代理模式有啥用呢" class="headerlink" title="静态代理模式有啥用呢?"></a>静态代理模式有啥用呢?</h2><p>在java的多线程中就用到了静态代理模式。</p>
<p>我们在实现多线程时，首先写一个自己的类MyRunnabale实现Runnable，接着通过<code>new Thread(new MyRunnable).start();</code>开启线程。</p>
<p>在Java中Thread实现了Runnable接口，因此在代理模式中，他们的扮演的身份分别是：</p>
<ul>
<li><strong>要代理的事情：</strong>Runnable中的run()方法</li>
<li><strong>委托类：</strong>你实现的类MyRunnable</li>
<li><strong>代理类：</strong>Thread</li>
</ul>
<p>继续学习：<a href="http://www.makerhu.com/posts/39d16fd4/">代理模式之动态代理 | MakerHu的博客</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
        <tag>proxy pattern</tag>
        <tag>静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux服务器上简易部署django项目</title>
    <url>/posts/58379ca9/</url>
    <content><![CDATA[<blockquote>
<p>本教程详细描述了如何简单实现在Linux服务器中部署django项目</p>
</blockquote>
<span id="more"></span>

<p><strong>未经允许请勿转载！</strong> 文章首发于<a href="https://www.makerhu.com/posts/58379ca9/">在Linux服务器上简易部署django项目 | MakerHu的博客</a></p>
<ol>
<li>安装好python3</li>
<li>创建虚拟环境<br> <code>python -m venv /虚拟环境名称/</code></li>
<li>进入虚拟环境<br> <code>cd /虚拟环境名/</code></li>
<li>进入bin目录<br> <code>cd bin</code></li>
<li>运行虚拟环境<br> <code>source activate</code></li>
<li>更新pip<br> <code>pip install --upgrade pip</code></li>
<li>查看当前安装的模块<br> <code>pip freeze</code></li>
<li>安装项目的django对应版本<br> <code>pip install django==3.1.3</code><br> 也可用清华镜像网安装（速度较快）<br> <code>pip install --upgrade -i https://pypi.tuna.tsinghua.edu.cn/simple django==3.1.3</code></li>
<li>再次查看安装模块<br> <code>pip freeze</code></li>
<li>接着把项目在本地安装的模块都装到虚拟环境中(根据自身项目具体情况安装）<br><code>pip install --upgrade -i https://pypi.tuna.tsinghua.edu.cn/simple pymysql</code><br><code>pip install --upgrade -i https://pypi.tuna.tsinghua.edu.cn/simple cryptography</code><br><code>pip install --upgrade -i https://pypi.tuna.tsinghua.edu.cn/simple apscheduler</code></li>
<li>安装http需要的模块<br> <code>pip install --upgrade -i https://pypi.tuna.tsinghua.edu.cn/simple gunicorn</code></li>
<li>安装bleach<br> <code>pip install --upgrade -i https://pypi.tuna.tsinghua.edu.cn/simple bleach</code></li>
<li>在服务器中配置项目的数据库，这里以mysql为例（mysql需先在linux系统中安装好）</li>
</ol>
<ul>
<li>登录root<br><code>mysql -u root -p</code></li>
<li>创建项目数据库<br><code>create database cms;</code></li>
<li>mysql创建新用户cmsmanager , 密码123456 (cmamanager为用户名, 123456为密码，可根据自己需要修改)<br><code>CREATE USER &#39;cmsmanager&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;</code></li>
<li>授予数据库cms的所有权限给cmsmanager<br><code>GRANT ALL PRIVILEGES ON cms.* TO &#39;cmsmanager&#39;@&#39;%&#39;;</code></li>
</ul>
<p><strong>如果登录cmsmanager账户时遇到错误</strong><br><code>ERROR 1045 (28000): Access denied for user &#39;cmsmanager&#39;@&#39;localhost&#39; (using password: YES)</code><br>可能是因为你有一个用户名为空的账户，mysql会先匹配它，然后就一直提示你密码错误，需要删掉这个匿名用户，然后执行 <code>FLUSH PRIVILEGES;</code>如下：<br><code>Delete FROM user Where User=&#39;&#39; and Host=&#39;localhost&#39;;</code><br><code>flush privileges;</code><br>14. 在django项目settings.py中配置好数据库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">  <span class="string">&#x27;default&#x27;</span>: &#123; </span><br><span class="line">    <span class="comment"># &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;NAME&#x27;: BASE_DIR / &#x27;db.sqlite3&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,   <span class="comment"># 设置数据库为mysql</span></span><br><span class="line">    <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;cms&#x27;</span>,         <span class="comment"># 数据库名 </span></span><br><span class="line">    <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;cmsmanager&#x27;</span>,       <span class="comment"># 账户 </span></span><br><span class="line">    <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>,    <span class="comment"># 密码</span></span><br><span class="line">    <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,     <span class="comment"># 数据库的ip</span></span><br><span class="line">    <span class="string">&#x27;PORT&#x27;</span>: <span class="number">3306</span>,     <span class="comment"># 数据库的端口 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在django项目<strong>settings.py</strong>中允许所有主机访问</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS = [<span class="string">&quot;*&quot;</span>]</span><br></pre></td></tr></table></figure>
<ol start="15">
<li><p>将项目打包压缩（删掉虚拟环境）</p>
</li>
<li><p>将项目压缩包上传至服务器中刚创建的虚拟环境（见第2步）的根目录下（与bin目录同级）并解压，我用的远程连接服务器的工具是mobaxterm</p>
<p><img src="/posts/58379ca9/20210504233104.png" alt="项目上传位置"></p>
<p>在阿里云安全组中开放端口<br><strong>如果不能访问端口</strong><br>则</p>
</li>
</ol>
<ul>
<li>查看防火墙状态：<br><code>systemctl status firewalld</code></li>
<li>实例中已经安装Firewalld并且已经启用firewalld.service，若需要放行 TCP 5050端口，执行命令<br><code>firewall-cmd --add-port=5050/tcp --permanent</code><br>返回结果为success即表示已经放行TCP 5050端口（端口号根据自己需要修改）。</li>
<li>最后重新加载防火墙即可：<br><code>firewall-cmd --reload</code></li>
</ul>
<ol start="17">
<li>最后，启动项目(这种方式如果关掉远程连接服务器的工具就停了，若要一直后台运行则跳过此步)<br><code>python manage.py runserver 0.0.0.0:5050</code></li>
<li>将项目后台运行（记得先启动虚拟环境：在虚拟环境的bin目录下 <code>source activate</code>）<br>参考教程：<a href="https://www.cnblogs.com/yoyoketang/p/10593731.html">https://www.cnblogs.com/yoyoketang/p/10593731.html</a></li>
</ol>
<ul>
<li><p>首先写一个启动文件：start.sh<br>在manage.py同级目录下<br><code>vim start.sh</code><br>输入：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ps</span> -aux | <span class="keyword">grep</span> <span class="keyword">python</span>|xargs kill -<span class="number">9</span></span><br><span class="line">nohup <span class="keyword">python</span> manage.<span class="keyword">py</span> runserver <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">5050</span> &gt;cms_website.out <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/58379ca9/20210504233154.png" alt="编辑start.sh"></p>
<p>编辑完成后按Esc建退出，输入<code>:wq</code>后按回车保存退出</p>
</li>
<li><p>同理编辑停止文件stop.sh<br>在manage.py同级目录下<br><code>vim stop.sh</code><br>输入：<br><code>ps -aux | grep python|xargs kill -9</code><br>编辑完成后Esc退出，输入<code>:wq</code>保存退出</p>
</li>
<li><p>都编辑完成后授权这两个文件<br><code>chmod +777 start.sh</code><br><code>chmod +777 stop.sh</code></p>
</li>
<li><p>启动时输入：<br><code>./start.sh</code></p>
</li>
<li><p>关闭服务输入：<br><code>./stop.sh</code></p>
</li>
<li><p>查看实时日志<br><code>tail -f cms_website.out</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>野生教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>django</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手SpringBoot项目（登录注册保姆级教程）</title>
    <url>/posts/5b2ca0db/</url>
    <content><![CDATA[<blockquote>
<p>本文章对SpringBoot开发后端项目结构做了简单介绍，并示范了使用SpringBoot+MySQL实现登录的后端功能，与本博客的另一篇文章 <a href="https://www.makerhu.com/posts/78e35d03/">Vue 实现登录注册功能（前后端分离完整案例） | MakerHu 的博客</a> 共同组成了前后端分离项目的整体，适合小白上手 Vue + SpringBoot + Mysql 的项目开发。</p>
</blockquote>
<span id="more"></span>

<p><strong>未经允许请勿转载！</strong> 文章首发于<a href="https://www.makerhu.com/posts/5b2ca0db/">快速上手SpringBoot项目（登录注册保姆级教程） | MakerHu的博客</a></p>
<p><strong>如果大家遇到问题并解决，可以及时向我反馈，我会把大家的解决方案补充到文章最后，以供他人参考，大家遇到问题也可以先到文末查看是否已有解决方案</strong></p>
<p><strong>前后端完整项目演示：</strong> </p>
<p><img src="/posts/5b2ca0db/20220215165842.gif" alt="前后端完整项目演示"></p>
<p><strong>本文章只涉及后端教程</strong>，前端教程请看本人的另一篇文章：</p>
<p><strong>前端教程：</strong><a href="https://www.makerhu.com/posts/78e35d03/">Vue 实现登录注册功能（前后端分离完整案例） | MakerHu 的博客</a></p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>使用本教程的前置条件是开发环境中已安装了以下几个东西，若无可以先找相关教程安装配置好。</p>
<p><strong>管理工具：</strong>maven</p>
<p><strong>IDE：</strong> IDEA</p>
<p><strong>数据库：</strong> MySQL</p>
<p><strong>测试工具：</strong>Postman（非必须，但方便测试且安装和使用都挺简单的）</p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><strong>注意：创建项目时保持网络通畅</strong></p>
<ol>
<li><p>打开IDEA</p>
<p><img src="/posts/5b2ca0db/20210629210809.png" alt="IDEA图标"></p>
</li>
<li><p>新建项目</p>
<p>情况一：</p>
<p><img src="/posts/5b2ca0db/20210629211408.png" alt="新建项目第一步"></p>
<p>情况二：</p>
<p><img src="/posts/5b2ca0db/20210629211755.png" alt="新建项目第一步"></p>
<p>设置项目的基本信息，其中注意jdk版本要与Java版本匹配，这里使用jdk1.8和java8</p>
</li>
</ol>
<p><img src="/posts/5b2ca0db/20210629223940.png" alt="新建项目第二步"></p>
<p>选择SpringBoot版本，选择项目依赖（依赖可以创建完项目后在pom文件中修改）</p>
<p><img src="/posts/5b2ca0db/20210629225008.png" alt="新建项目第三步"></p>
<p><img src="/posts/5b2ca0db/20210629225618.png" alt="新建项目第三步"></p>
<p>至此项目就创建完成啦！</p>
<h2 id="目录结构（初始状态）"><a href="#目录结构（初始状态）" class="headerlink" title="目录结构（初始状态）"></a>目录结构（初始状态）</h2><p><img src="/posts/5b2ca0db/20210629230552.png" alt="项目目录结构"></p>
<h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>创建完项目后，如果直接运行项目，我们会发现项目报错了</p>
<p><img src="/posts/5b2ca0db/20210629230907.png" alt="报错图"></p>
<p>报错的原因是我们在创建项目时导入了数据库相关的依赖，但是项目却还没有进行数据库相关配置</p>
<p>所以接下来我们先进行数据库的配置</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>要配置数据库，首先咱们得有个数据库，因此我们先用MySQL创建一个。由于本项目要演示登录注册功能的实现，所以在此我将创建一个用户表，保存用户的账号信息。</p>
<ol>
<li>按Win+R打开“运行”，输入cmd</li>
</ol>
<p><img src="/posts/5b2ca0db/20210629231452.png" alt="cmd"></p>
<ol start="2">
<li><p>输入<code>mysql -u root -p</code>后输入密码，登录MySQL</p>
<p><img src="/posts/5b2ca0db/20210629231749.png" alt="登录MySQL"></p>
</li>
<li><p>创建数据库<code>create database logindemo</code><strong>logindemo</strong>为数据库名，根据你的情况修改</p>
<p><img src="/posts/5b2ca0db/20210629232246.png" alt="创建数据库"></p>
</li>
<li><p>进入数据库<code>use logindemo</code></p>
<p><img src="/posts/5b2ca0db/20210629232535.png" alt="进入数据库"></p>
</li>
<li><p>创建user表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    uid <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">primary</span> key <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    uname <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> (uname)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/posts/5b2ca0db/20210629234318.png"></p>
<p>uid: 用户编号，主键，自增</p>
<p>uname: 用户名，作为登录的账号（业务主键），不可重复</p>
<p>password: 密码，因为可能要加密，所以长度设了较长的255</p>
</li>
<li><p>查看表是否创建成功</p>
<p><code>desc user;</code></p>
<p><img src="/posts/5b2ca0db/20210629234515.png" alt="查看user表信息"></p>
<p>到这数据库就创建完成啦，接下来就是在项目中配置数据库相关信息了。</p>
</li>
</ol>
<h3 id="配置数据库-1"><a href="#配置数据库-1" class="headerlink" title="配置数据库"></a>配置数据库</h3><ol>
<li><p>找到配置文件application.properties</p>
<p><img src="/posts/5b2ca0db/20210629235403.png"></p>
</li>
<li><p>输入数据库相关配置信息（此处配置了项目端口号为8081，可不配置，默认端口号为8080）</p>
<p><strong>注意：配置url处logindemo改为你的数据库名称</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置端口号为8081</span></span><br><span class="line"><span class="string">server.port=8081</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置数据库</span></span><br><span class="line"><span class="comment"># 配置驱动</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># 若连接的是云数据库则将localhost改为云端ip</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://localhost:3306/logindemo?serverTimezone=UTC</span></span><br><span class="line"><span class="comment"># Mysql用户</span></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="comment"># Mysql对应用户密码</span></span><br><span class="line"><span class="string">spring.datasource.password=123456</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/5b2ca0db/20210629235703.png" alt="application.properties"></p>
<p>现在再次运行项目就能成功运行啦！</p>
</li>
<li><p>在IDEA中连接数据库（此步非必须，只是为了开发方便）</p>
<p>在IDEA中连接数据库可以让我们在开发时直接可视化查看数据库的详细信息，建议配置一下。</p>
<p><img src="/posts/5b2ca0db/20210630000910.png"></p>
<p>配置数据库基本信息</p>
<p><strong>注意：这一步有可能出现时区错误或者缺少依赖文件！！！</strong></p>
<p><strong>解决方案</strong></p>
<p><strong>时区错误：</strong>见图中配置时区</p>
<p><strong>缺少文件：</strong>根据提示点击下载，但由于服务器在外网，有可能需要科学上网</p>
<p><img src="/posts/5b2ca0db/20210630001501.png"></p>
<p><img src="/posts/5b2ca0db/20210630002003.png"></p>
<p>完成以上配置后就能在IDEA中管理数据库啦！</p>
<p><img src="/posts/5b2ca0db/20210630002452.png"></p>
</li>
</ol>
<h2 id="项目架构图"><a href="#项目架构图" class="headerlink" title="项目架构图"></a>项目架构图</h2><p>在说项目的目录结构之前，我们先来聊一聊后端的架构大概是什么样的，方便我们对目录结构的理解。</p>
<p><img src="/posts/5b2ca0db/20210630010734.png" alt="项目架构图"></p>
<ul>
<li><strong>数据持久层</strong>是的目的是在java对象与数据库之间建立映射，也就是说它的作用是将某一个Java类对应到数据库中的一张表。在我们的项目中，就将创建一个实体类User映射到数据库的user表，表中的每个字段对应于实体类的每个属性。而之前配置的JPA的作用就是帮助我们完成类到数据表的映射。<ul>
<li>repository: 存放一些数据访问类（也就是一些能操纵数据库的类）的包，比如存放能对user表进行增删改查的类</li>
<li>domain：存放实体类的包，比如User类，其作为对应数据库user表的一个实体类</li>
</ul>
</li>
<li><strong>业务逻辑层</strong>的作用是处理业务逻辑。比如在本项目中，我们就在业务逻辑层实现登录注册的逻辑，像是判断是否有用户名重复，密码是否正确等逻辑<ul>
<li>service: 存放业务逻辑接口的包</li>
<li>serviceImpl: 存放业务逻辑实现类的包，其中的类实现service中的接口</li>
</ul>
</li>
<li><strong>控制层</strong>的作用是接收视图层的请求并调用业务逻辑层的方法。比如视图层请求登录并发来了用户的账号和密码，那么控制层就调用业务逻辑层的登录方法，并将账号密码作为参数传入，在将结果返回给视图层。<ul>
<li>controller: 存放控制器的包。比如UserController</li>
</ul>
</li>
<li><strong>视图层</strong>的作用是展现数据，由于本项目写的是纯后端，就不展开解释视图层了。</li>
</ul>
<p><strong>注意：根据架构我们可以发现，最佳的开发方式是自底向上开发，因为包之间的调用是上层调用下层，所以下层先实现能保证实现多少测试多少</strong></p>
<h2 id="完善项目的基本目录结构"><a href="#完善项目的基本目录结构" class="headerlink" title="完善项目的基本目录结构"></a>完善项目的基本目录结构</h2><p>根据上述架构图的设计，我们就能创建对应的包让我们的项目框架更加清晰了。</p>
<ol>
<li><p>创建各种包（以domain包为例）</p>
<p>注意本项目中service与serviceImpl包为父子关系，也可以并列，这取决于你的喜好</p>
<p>最终效果见下一步</p>
<p><img src="/posts/5b2ca0db/20210630013358.png" alt="创建包"></p>
<p><img src="/posts/5b2ca0db/20210630013719.png"></p>
</li>
<li><p>最终目录结构</p>
<p>包含<code>domain</code> <code>repository</code> <code>service</code> <code>serviceImpl</code> <code>controller</code> <code>utils</code> <code>config</code> </p>
<p><img src="/posts/5b2ca0db/20210630014607.png" alt="最终目录结构"></p>
<p>这时候眼尖的同学就发现了，怎么还多了俩： <code>utils</code> <code>config</code> </p>
<p>这两个包的作用：</p>
<ul>
<li>**utils: **存放工具类，一些自己封装的工具</li>
<li>**config: **存放配置类，一些配置如登录拦截器，安全配置等</li>
</ul>
<p>这里先建好了再说，具体怎么用之后会说。</p>
</li>
</ol>
<h2 id="登录注册功能实现"><a href="#登录注册功能实现" class="headerlink" title="登录注册功能实现"></a>登录注册功能实现</h2><p>根据框架特点，我们将自底向上开发，所以将按照 实体类-dao-service-serviceImpl-controller 的顺序逐步开发。</p>
<h3 id="所有类或接口的目录位置"><a href="#所有类或接口的目录位置" class="headerlink" title="所有类或接口的目录位置"></a>所有类或接口的目录位置</h3><p>为了方便你在下面的教程中明确的知道文件应该创建在什么位置，在此我就先把所有文件的目录位置展示出来了，你可以在需要的时候随时回来查看，现在可以先跳过这一步。</p>
<p><img src="/posts/5b2ca0db/20210630190513.png" alt="所有类或接口的目录位置"></p>
<h3 id="实现User实体类"><a href="#实现User实体类" class="headerlink" title="实现User实体类"></a>实现User实体类</h3><ol>
<li><p>在domain中创建User.java</p>
<p><img src="/posts/5b2ca0db/20210630021309.png" alt="创建User类"></p>
<p><img src="/posts/5b2ca0db/20210630021356.png" alt="创建User类"></p>
</li>
<li><p>创建对应user表中字段的属性</p>
<p>其中注意要添加<code>@Table(name = &quot;user&quot;)</code>和<code>@Entity</code>注解</p>
<ul>
<li><strong>@Table(name = “user”)</strong> 说明此实体类对应于数据库的user表</li>
<li><strong>@Entity</strong> 说明此类是个实体类</li>
</ul>
<p>主键uid上要加上<code>@Id</code>与<code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//domain中的User.java</span></span><br><span class="line"><span class="keyword">package</span> com.springboot.springbootlogindemo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Table(name = &quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意属性名要与数据表中的字段名一致</span></span><br><span class="line">    <span class="comment">// 主键自增int(10)对应long</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名属性varchar对应String</span></span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码属性varchar对应String</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/5b2ca0db/20210630021652.png"></p>
</li>
<li><p>为属性生成get,set方法</p>
<ul>
<li><p>将光标移至要插入get, set方法的位置</p>
</li>
<li><p>右键-generate-getter and setter</p>
<p><img src="/posts/5b2ca0db/20210630022152.png"></p>
<p><img src="/posts/5b2ca0db/20210630022249.png"></p>
</li>
<li><p>选中所有属性-OK</p>
<p><img src="/posts/5b2ca0db/20210630022502.png"></p>
</li>
<li><p>最后得到User.java（也可以纯手敲）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springboot.springbootlogindemo.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Table(name = &quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意属性名要与数据表中的字段名一致</span></span><br><span class="line">    <span class="comment">// 主键自增int(10)对应long</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名属性varchar对应String</span></span><br><span class="line">    <span class="keyword">private</span> String uname;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码属性varchar对应String</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(<span class="keyword">long</span> uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUname</span><span class="params">(String uname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uname = uname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此User实体类就创建好啦，如果要实现其他表的实体类也类似。</p>
</li>
</ul>
</li>
</ol>
<h3 id="实现UserDao"><a href="#实现UserDao" class="headerlink" title="实现UserDao"></a>实现UserDao</h3><ol>
<li><p>在repository包中创建UserDao接口</p>
<p><img src="/posts/5b2ca0db/20210630115952.png"></p>
<p><img src="/posts/5b2ca0db/20210630120140.png" alt="创建UserDao"></p>
</li>
<li><p>添加一些访问数据库的方法(这里添加的是根据用户名查询用户方法)</p>
<ul>
<li>首先要添加注解<code>@Repository</code></li>
<li>接口要继承<code>JpaRepository</code>，这样JPA就能帮助我们完成对数据库的映射，也就是说接口里写的方法只要符合格式可以不需要实现SQL语句就能直接用了。</li>
<li>如果JPA没有提供你想要的方法，可以自定义SQL语句</li>
</ul>
<p><img src="/posts/5b2ca0db/20210630185108.png" alt="UserDao"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springboot.springbootlogindemo.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springboot.springbootlogindemo.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findByUname</span><span class="params">(String uname)</span></span>; <span class="comment">//通过用户名uname查找用户，注意要按照JPA的格式使用驼峰命名法</span></span><br><span class="line">    <span class="function">User <span class="title">findByUnameAndPassword</span><span class="params">(String uname, String password)</span></span>;<span class="comment">//通过用户名uname和密码查找用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们只实现登录注册功能，所以只要有根据账号密码查询用户和插入用户信息的方法就行了，这里我们已经实现了根据用户名密码查找用户的方法，而插入用户信息的方法save(object o)JPA已经帮我们实现了，可以直接调用，这里就不需要写了。</p>
<p>**注意:**这里接口方法的命名要按照JPA提供的命名格式,比如findBy, deleteBy等等,且要求驼峰命名法。如果自定义查询方法可以不遵守这个规则</p>
<p>自定义查询方法例子(本项目不需要用到):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(value = &quot;select * from user where uname LIKE ?1 OR email LIKE ?2 OR lastdid LIKE ?3 OR uid LIKE ?4&quot;,nativeQuery = true)</span></span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findUserswithoutgender</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String uname,</span></span></span><br><span class="line"><span class="function"><span class="params">        String email,</span></span></span><br><span class="line"><span class="function"><span class="params">        String lastdid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String uid,</span></span></span><br><span class="line"><span class="function"><span class="params">        Pageable request</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="实现UserService"><a href="#实现UserService" class="headerlink" title="实现UserService"></a>实现UserService</h3><ol>
<li><p>在service包中创建UserService接口</p>
<p><img src="/posts/5b2ca0db/20210630153407.png" alt="创建UserService接口"></p>
<p><img src="/posts/5b2ca0db/20210630153737.png" alt="创建UserService接口"></p>
</li>
<li><p>添加登录注册需要用到的业务逻辑方法</p>
<ul>
<li>最终UserService的完整代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springboot.springbootlogindemo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springboot.springbootlogindemo.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录业务逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uname 账户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">loginService</span><span class="params">(String uname, String password)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册业务逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 要注册的User对象，属性中主键uid要为空，若uid不为空可能会覆盖已存在的user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">registService</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>完成了接口方法的定义，接下来是在UserServiceImpl中实现这些方法啦</p>
</li>
</ol>
<h3 id="实现UserServiceImpl"><a href="#实现UserServiceImpl" class="headerlink" title="实现UserServiceImpl"></a>实现UserServiceImpl</h3><p>我们将在UserServiceImpl中实现UserService中的方法，完整的UserServiceImpl代码在此步骤的最后一小步里</p>
<ol>
<li><p>在serviceImpl包中创建UserServiceImpl类</p>
<p><img src="/posts/5b2ca0db/20210630162053.png" alt="创建UserServiceImpl类"></p>
<p><img src="/posts/5b2ca0db/20210630162331.png" alt="创建UserServiceImpl类"></p>
</li>
<li><p>添加需要实现的方法</p>
<ul>
<li><p>添加<code>implements UserService</code></p>
<p>此时会报错，但没关系，只是因为方法还没实现。</p>
<p><img src="/posts/5b2ca0db/20210630162651.png"></p>
</li>
<li><p>鼠标悬停在红色波浪线自动生成需要实现的方法（也可以手动一个个写）</p>
<p><img src="/posts/5b2ca0db/20210630163207.png" alt="生成方法"></p>
<p><img src="/posts/5b2ca0db/20210630163356.png" alt="生成方法"></p>
</li>
<li><p>生成方法后的样子</p>
<p><img src="/posts/5b2ca0db/20210630164253.png" alt="生成方法后的样子"></p>
</li>
</ul>
</li>
<li><p>实现登录业务逻辑</p>
<ul>
<li><p>因为要用到UserDao中的方法，所以先通过<code>@Resource</code>注解帮助我们实例化UserDao对象</p>
</li>
<li><p>登录业务逻辑代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">loginService</span><span class="params">(String uname, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果账号密码都对则返回登录的用户对象，若有一个错误则返回null</span></span><br><span class="line">    User user = userDao.findByUnameAndPassword(uname, password);</span><br><span class="line">    <span class="comment">// 重要信息置空</span></span><br><span class="line">    <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span><br><span class="line">        user.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实现注册业务逻辑</p>
<ul>
<li><p>注册业务逻辑代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">registService</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当新用户的用户名已存在时</span></span><br><span class="line">    <span class="keyword">if</span>(userDao.findByUname(user.getUname())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 无法注册</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//返回创建好的用户对象(带uid)</span></span><br><span class="line">        User newUser = userDao.save(user);</span><br><span class="line">        <span class="keyword">if</span>(newUser != <span class="keyword">null</span>)&#123;</span><br><span class="line">            newUser.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>添加<code>@Service</code>注解</p>
<p><img src="/posts/5b2ca0db/20210630182301.png" alt="添加@Service注解"></p>
</li>
<li><p>最终UserServiceImpl完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springboot.springbootlogindemo.service.serviceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springboot.springbootlogindemo.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.springboot.springbootlogindemo.repository.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.springboot.springbootlogindemo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">loginService</span><span class="params">(String uname, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果账号密码都对则返回登录的用户对象，若有一个错误则返回null</span></span><br><span class="line">        User user = userDao.findByUnameAndPassword(uname, password);</span><br><span class="line">        <span class="comment">// 重要信息置空</span></span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span><br><span class="line">            user.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">registService</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当新用户的用户名已存在时</span></span><br><span class="line">        <span class="keyword">if</span>(userDao.findByUname(user.getUname())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 无法注册</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//返回创建好的用户对象(带uid)</span></span><br><span class="line">            User newUser = userDao.save(user);</span><br><span class="line">            <span class="keyword">if</span>(newUser != <span class="keyword">null</span>)&#123;</span><br><span class="line">                newUser.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newUser;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>至此UserServiceImpl就写完啦！</p>
</li>
</ol>
<h3 id="实现工具类Result"><a href="#实现工具类Result" class="headerlink" title="实现工具类Result"></a>实现工具类Result</h3><p>工具类Result的作用是作为返回给前端的统一后的对象。也就是说返回给前端的都是Result对象，只是对象中的属性不太一样，这样方便前端固定接收格式。</p>
<ol>
<li><p>在utils包中创建Result类</p>
<p><img src="/posts/5b2ca0db/20210630175732.png" alt="创建Result类"></p>
<p><img src="/posts/5b2ca0db/20210630180002.png" alt="创建Result类"></p>
</li>
<li><p>最终Result代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springboot.springbootlogindemo.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result&lt;&gt;();</span><br><span class="line">        result.setCode(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        result.setMsg(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Result&lt;T&gt; <span class="title">success</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> Result&lt;&gt;(data);</span><br><span class="line">        result.setCode(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        result.setMsg(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Result&lt;T&gt; <span class="title">success</span><span class="params">(T data,String msg)</span> </span>&#123;</span><br><span class="line">        Result&lt;T&gt; result = <span class="keyword">new</span> Result&lt;&gt;(data);</span><br><span class="line">        result.setCode(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        result.setMsg(msg);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">error</span><span class="params">(String code, String msg)</span> </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result();</span><br><span class="line">        result.setCode(code);</span><br><span class="line">        result.setMsg(msg);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出Result是个模板类，因此想要返回什么数据类型给前端都行，如<code>Result&lt;User&gt;</code>，要是没看懂没关系，看到下面就知道怎么用了。因为里面有很多静态方法，可以直接用<code>类名.方法名</code>调用。</p>
</li>
</ol>
<h3 id="实现UserController"><a href="#实现UserController" class="headerlink" title="实现UserController"></a>实现UserController</h3><ol>
<li><p>在controller包中创建UserController类</p>
<p><img src="/posts/5b2ca0db/20210630174130.png" alt="创建UserController类"></p>
<p><img src="/posts/5b2ca0db/20210630174215.png" alt="创建UserController类"></p>
</li>
<li><p>添加<code>@RestController</code>与<code>@RequestMapping(&quot;/user&quot;)</code>注解，注入UserService</p>
<ul>
<li>注解@RequestMapping中的”/user”是这个控制器类的基路由</li>
</ul>
<p><img src="/posts/5b2ca0db/20210630175120.png"></p>
</li>
<li><p>实现登录的控制</p>
<p>这里的<code>@PostMapping(&quot;/login&quot;)</code>表示处理post请求，路由为/user/login</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;User&gt; <span class="title">loginController</span><span class="params">(<span class="meta">@RequestParam</span> String uname, <span class="meta">@RequestParam</span> String password)</span></span>&#123;</span><br><span class="line">    User user = userService.loginService(uname, password);</span><br><span class="line">    <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(user,<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;账号或密码错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现注册的控制</p>
<p>这里的<code>@PostMapping(&quot;/register&quot;)</code>表示处理post请求，路由为/user/register</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;User&gt; <span class="title">registController</span><span class="params">(<span class="meta">@RequestBody</span> User newUser)</span></span>&#123;</span><br><span class="line">    User user = userService.registService(newUser);</span><br><span class="line">    <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success(user,<span class="string">&quot;注册成功！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;456&quot;</span>,<span class="string">&quot;用户名已存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>完整的UserController代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springboot.springbootlogindemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springboot.springbootlogindemo.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.springboot.springbootlogindemo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.springboot.springbootlogindemo.utils.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;User&gt; <span class="title">loginController</span><span class="params">(<span class="meta">@RequestParam</span> String uname, <span class="meta">@RequestParam</span> String password)</span></span>&#123;</span><br><span class="line">        User user = userService.loginService(uname, password);</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.success(user,<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;123&quot;</span>,<span class="string">&quot;账号或密码错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;User&gt; <span class="title">registController</span><span class="params">(<span class="meta">@RequestBody</span> User newUser)</span></span>&#123;</span><br><span class="line">        User user = userService.registService(newUser);</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.success(user,<span class="string">&quot;注册成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;456&quot;</span>,<span class="string">&quot;用户名已存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="处理跨域访问问题"><a href="#处理跨域访问问题" class="headerlink" title="处理跨域访问问题"></a>处理跨域访问问题</h2><blockquote>
<p>跨域问题可以简单理解成如果你的前端项目的<strong>IP地址</strong>和<strong>端口号</strong>和后端的<strong>IP地址</strong>和<strong>端口号</strong>不一样，就会导致前端无法获取到数据，这是一个规定。而在前后端分离开发的项目中，前后端项目的端口号一般都是不一样的，假设我们这个项目的前端端口号是 8080，后端端口号是 8081，就会造成跨域访问的问题，跨域访问的问题可以在前端解决也可以在后端解决，后端只要加上一个配置文件就行了</p>
</blockquote>
<ul>
<li><p>在<code>config</code>文件下创建全局跨域配置类<code>GlobalCorsConfig.java</code></p>
<p><img src="/posts/5b2ca0db/20220206000716.png" alt="创建全局跨域配置文件"></p>
</li>
<li><p><strong>GlobalCorsConfig.java 文件</strong></p>
<p><strong>注意！！！</strong> ：<strong>SpringBoot2.4.0</strong> 以后下方 <code>allowedOrigins</code> 需要被 <code>allowedOriginPatterns</code> 代替！！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springboot.springbootlogindemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalCorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/**&quot;</span>)    <span class="comment">//添加映射路径，“/**”表示对所有的路径实行全局跨域访问权限的设置</span></span><br><span class="line">                        .allowedOrigins(<span class="string">&quot;*&quot;</span>)    <span class="comment">//开放哪些ip、端口、域名的访问权限 SpringBoot2.4.0以后allowedOrigins被allowedOriginPatterns代替</span></span><br><span class="line">                        .allowCredentials(<span class="keyword">true</span>)  <span class="comment">//是否允许发送Cookie信息</span></span><br><span class="line">                        .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)     <span class="comment">//开放哪些Http方法，允许跨域访问</span></span><br><span class="line">                        .allowedHeaders(<span class="string">&quot;*&quot;</span>)     <span class="comment">//允许HTTP请求中的携带哪些Header信息</span></span><br><span class="line">                        .exposedHeaders(<span class="string">&quot;*&quot;</span>);   <span class="comment">//暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理跨域问题是为前后端分离开发做铺垫，这里这样配置好就行了，暂时放着不需要管，等开发前端 Vue 项目时就不会出问题了。</p>
<p>至此所有的代码就都写完啦！！！</p>
<p>接下来就是运行测试一下是否成功就行了。</p>
</li>
</ul>
<h2 id="Postman测试"><a href="#Postman测试" class="headerlink" title="Postman测试"></a>Postman测试</h2><ol>
<li><p>打开postman</p>
<p><img src="/posts/5b2ca0db/20210630182908.png" alt="postman"></p>
</li>
<li><p>测试注册用户</p>
<p><img src="/posts/5b2ca0db/20210630183243.png" alt="测试注册"></p>
<p>输入选则请求方式Post，输入路由<code>http://localhost:8081/user/register</code>，输入用户json对象后点击<strong>Send</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;uname&quot;</span>: <span class="string">&quot;hhh&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功收到后端返回消息</p>
<p><img src="/posts/5b2ca0db/20210630183612.png" alt="注册成功消息"></p>
</li>
<li><p>登录测试</p>
<p><img src="/posts/5b2ca0db/20210630183907-164839402645947.png" alt="登录测试"></p>
<p>类似于注册测试</p>
<ul>
<li>请求方式：POST</li>
<li>url：<code>http://localhost:8081/user/login</code></li>
<li>参数：见图中4，5步</li>
</ul>
<p>至此整个项目都写完并测试完啦！感谢你能耐心看到这，希望本教程对你有所帮助。</p>
</li>
</ol>
<h2 id="项目源代码"><a href="#项目源代码" class="headerlink" title="项目源代码"></a>项目源代码</h2><ul>
<li>Vue 前端：<a href="https://github.com/MakerHu/vue-login-demo">MakerHu/vue-login-demo (github.com)</a></li>
<li>SpringBoot 后端：<a href="https://github.com/MakerHu/springboot-login-demo">MakerHu/springboot-login-demo (github.com)</a></li>
</ul>
<h2 id="相关推荐"><a href="#相关推荐" class="headerlink" title="相关推荐"></a>相关推荐</h2><ul>
<li>前端教程：<a href="https://www.makerhu.com/posts/78e35d03/">Vue 实现登录注册功能（前后端分离完整案例） | MakerHu 的博客</a></li>
</ul>
<h2 id="可能遇到的问题与解决方案"><a href="#可能遇到的问题与解决方案" class="headerlink" title="可能遇到的问题与解决方案"></a>可能遇到的问题与解决方案</h2><p>此章节列出一些朋友在使用本教程中遇到并解决的问题，由于问题不太好复现，我就不具体验证解决方案的可行性了，此处列出仅供大家参考~ 非常感谢大家能为项目提出宝贵的意见！</p>
<p><strong>1. javax包更名为jakarta包导致的相关问题（感谢 @Pan-zg）</strong></p>
<p><strong>问题1：</strong><br>在教程中的新建User.class类中，有一个import内容：import javax.persistence.; 但在我导入的过程中，发现似乎现在这个javax包已经更名为jakarta包，相应的导入也改为：import jakarta.persistence.;</p>
<p><strong>问题2：</strong><br>在按照教程配置好数据库并初次启动（教程 4.2 第2部分）时，发生报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Unable to determine Dialect without JDBC metadata (please set &#x27;javax.persistence.jdbc.url&#x27;, &#x27;hibernate.connection.url&#x27;, or &#x27;hibernate.dialect&#x27;)</span><br></pre></td></tr></table></figure>
<p>最后我查找到的解决方法为：<br>在application.properties文件（或yaml）文件中添加一行代码：<br>spring.jpa.database-platform = org.hibernate.dialect.MySQLDialect<br>之后运行数据库，报错消失，运行正常。</p>
<p>以上就是我按照教程一步步建立项目并运行过程中遇到的主要问题，另外还有一些小问题，比如数据库url的配置中，可能需要添加一些其他参数，如useSSL等，也要按照每个人不同的运行环境进行调整。<br>总之，希望这些内容能帮助到其他跟我一样的初学者，另外再次感谢作者贡献这个对初学者友好的项目 👍</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>野生教程</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>MySQL</tag>
        <tag>SpringBoot+MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>注解与反射</title>
    <url>/posts/41268e44/</url>
    <content><![CDATA[<blockquote>
<p>注解与注释其实非常的相似，只不过注释是用来让开发人员知道某段代码的作用是什么都有哪些参数等，而注解则是写给程序看的一个“注释”，注解中主要包含了它本身的名称，以及它的参数，单纯地看一个注解其实与注释没啥区别。但注解往往会与反射组合使用，反射可以让我们在程序运行时观察并操作某个类中的信息，当然包括注解，这在实现一些框架的过程中有很大作用（比如实现实体类到数据库表的自动映射）。</p>
</blockquote>
<span id="more"></span>

<h2 id="注解（Annotation）"><a href="#注解（Annotation）" class="headerlink" title="注解（Annotation）"></a>注解（Annotation）</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><blockquote>
<p>元注解的作用是注解其他的注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型的说明。</p>
<p>存在包java.lang.annotation中</p>
</blockquote>
<p><strong>四个标准元注解：</strong></p>
<blockquote>
<p>注解注解的注解，也就是注解的注解，只能用在注解上。</p>
</blockquote>
<ul>
<li><strong>@Target</strong> 用于描述注解的使用范围（如方法、类、字段上等）</li>
<li><strong>@Retention</strong> 表示在什么级别保存该注释信息，用于描述注解的生命周期<ul>
<li>SOURCE &lt; CLASS &lt; RUNTIME</li>
</ul>
</li>
<li><strong>@Document</strong> 说明该注解将被包含在javadoc中</li>
<li><strong>@Inherited</strong> 说明子类可以继承父类中的该注解</li>
</ul>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>	<span class="comment">// 示例在这</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> myAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中参数ElementType的可选值有：</p>
<p><code>TYPE</code> <code>FIELD</code> <code>METHOD</code> <code>PARAMETER</code> <code>CONSTRUCTOR</code> <code>LOCAL_VARIABLE</code> <code>ANNOTATION_TYPE</code> <code>PACKAGE</code> <code>TYPE_PARAMETER</code> <code>TYPE_USE</code></p>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><blockquote>
<p>表示注解在什么范围有效，如源码级别、编译后的class级别、运行时级别</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>	<span class="comment">// 示例在这</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中参数的可选值有：</p>
<p><code>SOURCE</code> <code>CLASS</code> <code>RUNTIME</code></p>
<p>参数的关系为<strong>包含</strong>关系，<strong>RUNTIME &gt; CLASS &gt; SOURCE</strong></p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>自定义多参数的注解示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">// @interface 自动继承java.lang.annotation.Annotation接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 自定义注解的参数：注解的类型 参数名称();</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;defaultName&quot;</span>;    <span class="comment">// 参数可以设定默认值，否则使用该注解是时就必须写参数</span></span><br><span class="line">    <span class="function">String <span class="title">school</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义只带一个参数的注解示例：</p>
<p>如果之定义一个参数最好将参数命名为<code>value()</code>，因为命名为value在使用注解时可以省略<code>value = </code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">// @interface 自动继承java.lang.annotation.Annotation接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 自定义注解的参数：注解的类型 参数名称();</span></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反射（Reflection）"><a href="#反射（Reflection）" class="headerlink" title="反射（Reflection）"></a>反射（Reflection）</h2><blockquote>
<p><strong>反射式编程</strong>（英语：reflective programming）或<strong>反射</strong>（英语：reflection），是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。——维基百科</p>
</blockquote>
<h3 id="理解反射"><a href="#理解反射" class="headerlink" title="理解反射"></a>理解反射</h3><p>我对反射的一个比较形象的理解是，java中的反射与物理中光的反射也有一些相似的地方。在现实生活中，我们能够通过镜子看到某个物体反射后的像，而java中的反射就是以类加载过程中会生成的<strong>Class对象</strong>作为“镜子”，通过这面镜子，我们能在程序运行时观察并操作某个类的内部结构。因此学习反射绕不开对Class类的学习。（个人的理解，可能表达并不准确）</p>
<h3 id="反射机制提供的功能"><a href="#反射机制提供的功能" class="headerlink" title="反射机制提供的功能"></a>反射机制提供的功能</h3><ul>
<li>在运行时判断任意一个对象所属的类型</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
<li>……</li>
</ul>
<h3 id="理解java中的Class类"><a href="#理解java中的Class类" class="headerlink" title="理解java中的Class类"></a>理解java中的Class类</h3><p><strong>Class类</strong></p>
<ul>
<li>Class本身也是一个类</li>
<li>Class类<strong>只能由系统创建</strong>对象</li>
<li>一个加载的类在JVM中有且仅有一个Class实例</li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>
<li>每个类的实例都会知道自己是由哪个Class实例所生成</li>
<li>通过Class可以完全地得到一个类中的所有被加载的结构</li>
<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>
</ul>
<h3 id="获取Class对象的几种方式"><a href="#获取Class对象的几种方式" class="headerlink" title="获取Class对象的几种方式"></a>获取Class对象的几种方式</h3><p>这里我们写了两个类Person与Student，其中Student继承Person，本文章中所有的Person类与Student类都是以下列出的代码。</p>
<p><strong>Person类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.experiment.annotation.MyAnnotation;</span><br><span class="line"><span class="keyword">import</span> com.experiment.annotation.MyAnnotation02;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation(name = &quot;MakerHu&quot;, school = &quot;BJTU&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation02(&quot;studentCardId&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String studentId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStudentId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> studentId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudentId</span><span class="params">(String studentId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studentId = studentId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>通过代码可以更好地理解如何获取Class对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.experiment.reflection.getclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Person student1 = <span class="keyword">new</span> Student(<span class="string">&quot;学生&quot;</span>);</span><br><span class="line">        Person student2 = <span class="keyword">new</span> Student(<span class="string">&quot;学生&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Class对象的几种方法</span></span><br><span class="line">        <span class="comment">// 方法一：通过对象获得</span></span><br><span class="line">        Class c1_1 = student1.getClass();</span><br><span class="line">        Class c1_2 = student2.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二：通过Class.forName获得（需要抛出异常）</span></span><br><span class="line">        Class c2 = Class.forName(<span class="string">&quot;com.experiment.reflection.getclass.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法三：通过类名.Class获得（效率最高）</span></span><br><span class="line">        Class c3 = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式四：基本内置类型的包装类有一个Type属性</span></span><br><span class="line">        Class c4 = Integer.TYPE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得父类类型</span></span><br><span class="line">        Class c5 = c1_1.getSuperclass();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;c1_1: &quot;</span> + c1_1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;c1_2: &quot;</span> + c1_2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;c2: &quot;</span> + c2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;c3: &quot;</span> + c3.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;c4: &quot;</span> + c4);</span><br><span class="line">        System.out.println(<span class="string">&quot;c5: &quot;</span> + c5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的输出为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c1_1: 460141958</span><br><span class="line">c1_2: 460141958</span><br><span class="line">c2: 460141958</span><br><span class="line">c3: 460141958</span><br><span class="line">c4: int</span><br><span class="line">c5: class com.experiment.reflection.getclass.Person</span><br></pre></td></tr></table></figure>

<p>从c1到c3的输出我们可以发现，不管Class对象是如何获得的，只要其为某个类的Class对象，其在内存中就只有一个，也就是<strong>一个类拥有唯一的一个Class对象</strong>。</p>
<h3 id="通过Class对象获取类的信息"><a href="#通过Class对象获取类的信息" class="headerlink" title="通过Class对象获取类的信息"></a>通过Class对象获取类的信息</h3><p>不说废话，直接上代码，详见注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.experiment.reflection.getClassMsg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得类的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetClassMsg</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.experiment.reflection.getclass.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得类的名字</span></span><br><span class="line">        System.out.println(c1.getName());   <span class="comment">// 获得包名+类名</span></span><br><span class="line">        System.out.println(c1.getSimpleName()); <span class="comment">// 获得类名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得类的属性</span></span><br><span class="line">        Field[] fields = c1.getFields();    <span class="comment">// getFields()只能获取到本类或父类中的publics属性</span></span><br><span class="line">        fields = c1.getDeclaredFields();    <span class="comment">// getDeclaredFields()可以获取到本类所有属性</span></span><br><span class="line">        Field name = c1.getField(<span class="string">&quot;name&quot;</span>);   <span class="comment">// 获取到本类或父类中的指定名称的public属性</span></span><br><span class="line">        Field studentId = c1.getDeclaredField(<span class="string">&quot;studentId&quot;</span>); <span class="comment">// 获取到本类的指定名称的属性，private属性也可获取到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得类中的方法</span></span><br><span class="line">        Method[] methods = c1.getMethods(); <span class="comment">// 获得本类及其父类的所有public方法</span></span><br><span class="line">        methods = c1.getDeclaredMethods();  <span class="comment">// 获得本类的所有方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得指定的方法</span></span><br><span class="line">        Method setName = c1.getMethod(<span class="string">&quot;setName&quot;</span>,String.class);  <span class="comment">// 通过方法名和参数类型获取本类或父类的指定public方法，为的是防止有重载时找不到特定方法</span></span><br><span class="line">        Method setStudentId = c1.getDeclaredMethod(<span class="string">&quot;setStudentId&quot;</span>,String.class);    <span class="comment">//获取本类的所有指定方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造器</span></span><br><span class="line">        Constructor[] constructors = c1.getConstructors();  <span class="comment">// 获取本类所有public构造器</span></span><br><span class="line">        Constructor[] constructors1 = c1.getDeclaredConstructors(); <span class="comment">// 获取本类的所有构造器</span></span><br><span class="line">        Constructor constructor = c1.getConstructor(String.class);  <span class="comment">//获得本类的指定参数的public构造器</span></span><br><span class="line">        Constructor constructor1 = c1.getDeclaredConstructor(<span class="keyword">null</span>);  <span class="comment">//获得本类的指定参数的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="动态操作对象"><a href="#动态操作对象" class="headerlink" title="动态操作对象"></a>动态操作对象</h3><p>同样，看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.experiment.reflection.operateObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.experiment.reflection.getclass.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态操作对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.experiment.reflection.getclass.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造一个对象</span></span><br><span class="line">        Student student = (Student)c1.newInstance();    <span class="comment">//利用无参构造器构造</span></span><br><span class="line"></span><br><span class="line">        Constructor constructor = c1.getDeclaredConstructor(String.class);</span><br><span class="line">        Student student1 = (Student) constructor.newInstance(<span class="string">&quot;Makerhu&quot;</span>);    <span class="comment">// 利用有参构造器构造</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射调用方法</span></span><br><span class="line">        Method setStudentId = c1.getDeclaredMethod(<span class="string">&quot;setStudentId&quot;</span>, String.class);</span><br><span class="line">        setStudentId.invoke(student1,<span class="string">&quot;123425&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射操作属性</span></span><br><span class="line">        Field studentId = c1.getDeclaredField(<span class="string">&quot;studentId&quot;</span>);</span><br><span class="line">        studentId.setAccessible(<span class="keyword">true</span>);  <span class="comment">// 私有属性设置访问权限为true后就可以修改</span></span><br><span class="line">        studentId.set(student1, <span class="string">&quot;9876543&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取泛型信息"><a href="#获取泛型信息" class="headerlink" title="获取泛型信息"></a>获取泛型信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.experiment.reflection.getclass.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射获取泛型信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateGenericType</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">(Map&lt;String, Student&gt; map, List&lt;Student&gt; list, String str)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test01&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Map&lt;String, Student&gt; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test02&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">            Method method = OperateGenericType.class.getMethod(<span class="string">&quot;test01&quot;</span>,Map.class,List.class,String.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取参数类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;获取参数类型&quot;</span>);</span><br><span class="line">            Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;\n# &quot;</span> + genericParameterType);</span><br><span class="line">                  <span class="keyword">if</span> (genericParameterType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line">                        Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">                        <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                              System.out.println(actualTypeArgument);</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取返回值类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\n获取返回值类型&quot;</span>);</span><br><span class="line">            method = OperateGenericType.class.getMethod(<span class="string">&quot;test02&quot;</span>);</span><br><span class="line">            Type genericReturnType = method.getGenericReturnType();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                  Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">                  <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">                        System.out.println(actualTypeArgument);</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">获取参数类型</span><br><span class="line"></span><br><span class="line"><span class="comment"># java.util.Map&lt;java.lang.String, com.experiment.reflection.getclass.Student&gt;</span></span><br><span class="line">=================</span><br><span class="line">class java.lang.String</span><br><span class="line">class com.experiment.reflection.getclass.Student</span><br><span class="line"></span><br><span class="line"><span class="comment"># java.util.List&lt;com.experiment.reflection.getclass.Student&gt;</span></span><br><span class="line">=================</span><br><span class="line">class com.experiment.reflection.getclass.Student</span><br><span class="line"></span><br><span class="line"><span class="comment"># class java.lang.String</span></span><br><span class="line"></span><br><span class="line">获取返回值类型</span><br><span class="line">class java.lang.String</span><br><span class="line">class com.experiment.reflection.getclass.Student</span><br></pre></td></tr></table></figure>



<h3 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h3><p>先看看自定义的两个注解MyAnnotation与MyAnnotation02，这两个注解在Student类中被使用，具体看前面的Student类的代码。</p>
<p><strong>注解1：MyAnnotation</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;defaultName&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">school</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解2：MyAnnotation02</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation02 &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过反射获取注解信息：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.experiment.annotation.MyAnnotation;</span><br><span class="line"><span class="keyword">import</span> com.experiment.annotation.MyAnnotation02;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射获取注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;com.experiment.reflection.getclass.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射获得某个类的类注解</span></span><br><span class="line">        Annotation[] annotations = c1.getAnnotations();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取某个特定的注解</span></span><br><span class="line">        <span class="comment">// 方法一</span></span><br><span class="line">        MyAnnotation annotation = (MyAnnotation) c1.getAnnotation(MyAnnotation.class);</span><br><span class="line">        <span class="comment">// 方法二</span></span><br><span class="line">        Field field = c1.getDeclaredField(<span class="string">&quot;studentId&quot;</span>);</span><br><span class="line">        MyAnnotation02 annotation02 = field.getAnnotation(MyAnnotation02.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得注解的参数的值</span></span><br><span class="line">        System.out.println(annotation.name());</span><br><span class="line">        System.out.println(annotation.school());</span><br><span class="line">        System.out.println(annotation02.value());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>笔记整理于：<a href="https://www.bilibili.com/video/BV1p4411P7V3">【狂神说Java】注解和反射_哔哩哔哩_bilibili</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>笔记</category>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>annotation</tag>
        <tag>反射</tag>
        <tag>reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫实现力扣(LeetCode)本地刷题的快捷工具</title>
    <url>/posts/fe73207c/</url>
    <content><![CDATA[<blockquote>
<p>相信大家都在力扣上刷过题，力扣上虽然能在线写题，但在线编译运行的速度先对于本地运行还是比较慢，且一些自动补全的功能也不如自己的IDE优秀，因此，我们一般会在本地建个小项目解题，解完后再复制到力扣上提交。为了方便我们在本地快速搭建起力扣的解题环境，我写了一个小工具帮助我们把力扣的题目描述爬取到本地，并生成基础的代码，这样我们就能快速地专注于解题本身了。接下来我将展示一下工具的使用效果，并向大家提供源代码及部署方式。</p>
</blockquote>
<span id="more"></span>

<p><strong>未经允许请勿转载！</strong> 文章首发于<a href="https://www.makerhu.com/posts/fe73207c/">爬虫实现力扣(LeetCode)本地刷题的快捷工具 | MakerHu的博客</a></p>
<h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><ol>
<li>复制路径中的题目英文名</li>
</ol>
<p><img src="/posts/fe73207c/20210809214602.png" alt="路径中的题目英文名"></p>
<ol start="2">
<li><p>运行打包好的jar包</p>
<p><img src="/posts/fe73207c/20210809215022.png" alt="运行打包好的jar包"></p>
</li>
<li><p>打开本地项目</p>
<p><img src="/posts/fe73207c/20210809215244.png" alt="打开本地项目"></p>
</li>
<li><p>开始本地专注解题</p>
<p><img src="/posts/fe73207c/20210809215417.png" alt="本地解题"></p>
</li>
</ol>
<p>是不是非常地方便快捷😁</p>
<p>如果你也想拥有一个这样的工具就接着往下看吧，二十分钟之内你也能实现上述的效果哈！</p>
<h2 id="项目部署与打包"><a href="#项目部署与打包" class="headerlink" title="项目部署与打包"></a>项目部署与打包</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>环境要求：</strong></p>
<ul>
<li>jdk1.8（最好是1.8，其他版本我没有试过）</li>
<li>Maven</li>
<li>git</li>
<li>IDEA（当然也能用你喜欢的集成开发环境）</li>
<li>IDEA安装markdown插件（为的是能够有上述题目在本地的显示效果，否则可能显示的是纯文本）</li>
</ul>
<p>具体的环境搭建我就不教学了，网上的教程非常多且详细，相信大家都能搭建起来。</p>
<h3 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h3><p><strong>项目地址：</strong></p>
<p><a href="https://github.com/MakerHu/LeetCodeSpiderJava">MakerHu/LeetCodeSpiderJava: 爬取力扣的题目并在本地生成基础的项目文件 (github.com)</a></p>
<ol>
<li><p>打开IDEA，点击Git-&gt;Clone</p>
<p><img src="/posts/fe73207c/20210809221315.png" alt="点击Git-&gt;Clone"></p>
</li>
<li><p>点击上方的项目地址，复制仓库的url</p>
<p><img src="/posts/fe73207c/20210809221617.png"></p>
</li>
<li><p>将url粘贴到刚刚打开的Clone窗口中，并选择项目位置，点击Clone</p>
<p><img src="/posts/fe73207c/20210809222733.png" alt="把项目克隆到本地"></p>
</li>
<li><p>稍等一会儿，等项目依赖自动配置完后点击启动类中的运行</p>
<p><img src="/posts/fe73207c/20210809233000.png" alt="运行项目"></p>
</li>
<li><p>若显示下面的运行结果则说明项目运行成功了</p>
<p><img src="/posts/fe73207c/20210809233111.png" alt="项目运行成功"></p>
</li>
</ol>
<h3 id="创建本地刷题项目"><a href="#创建本地刷题项目" class="headerlink" title="创建本地刷题项目"></a>创建本地刷题项目</h3><p>我们把刷题和爬取题目的项目分离开来，为的是解耦，也方便之后的迁移与重用。</p>
<p>这里我将演示创建一个基础的java项目，当然你也可以创建Maven项目等，因为爬虫工具的原理是在某个文件夹下创建文件夹，并将题目内容markdown文件及基础代码创建到该文件夹下。</p>
<ol>
<li><p>创建一个基础的java项目</p>
<p><img src="/posts/fe73207c/20210810110103.png"></p>
<p><img src="/posts/fe73207c/20210810110158.png"></p>
<p><img src="/posts/fe73207c/20210810110333.png"></p>
</li>
</ol>
<h3 id="在爬虫项目的配置文件中配置基本信息"><a href="#在爬虫项目的配置文件中配置基本信息" class="headerlink" title="在爬虫项目的配置文件中配置基本信息"></a>在爬虫项目的配置文件中配置基本信息</h3><p><strong>打开爬虫项目的配置文件</strong></p>
<p><img src="/posts/fe73207c/20210810113838.png"></p>
<p>配置文件settings.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Java项目中要存放解题的根文件夹，如 E:/LeetCode/src/com/leetcode</span></span><br><span class="line"><span class="attr">question_location</span> = <span class="string">E:/000_collection/myLeetCode/src/com/leetcode</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解题所在的包 如：com.leetcode 若没有(也就是放在src文件夹下)则为空</span></span><br><span class="line"><span class="attr">base_package</span> = <span class="string">com.leetcode</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解题文件夹名称的前缀（可以是任意字符串）</span></span><br><span class="line"><span class="meta">folder.prefix</span> = <span class="string">p</span></span><br><span class="line"><span class="comment"># 解题文件夹是否包含力扣题目名（true 或 false）</span></span><br><span class="line"><span class="meta">folder.include_question_name</span> = <span class="string">true</span></span><br><span class="line"><span class="comment"># 解题文件夹是否按照时间分类（true 或 false）</span></span><br><span class="line"><span class="attr">sort_by_time</span> = <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来存储题目信息的markdown文件的前缀（可以是任意字符串）</span></span><br><span class="line"><span class="meta">question_markdown_filename.prefix</span> = <span class="string">p</span></span><br><span class="line"><span class="comment"># 用来存储题目信息的markdown文件名是否包含题目编号（true 或 false）</span></span><br><span class="line"><span class="meta">question_markdown_filename.include_question_id</span> = <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来存储题目信息的markdown文件名是否包含题目名以及是否用中文题目名命名（true 或 false）</span></span><br><span class="line"><span class="meta">question_markdown_filename.include_question_name</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">question_markdown_filename.zh_cn</span> = <span class="string">true</span></span><br></pre></td></tr></table></figure>



<h4 id="配置基本路径及基础包"><a href="#配置基本路径及基础包" class="headerlink" title="配置基本路径及基础包"></a>配置基本路径及基础包</h4><p><strong>基本路径：question_location</strong></p>
<p>在settings.proterties配置文件中的属性<code>question_location</code>表示解题的根路径，爬虫创建的文件夹将会放到该路径下。</p>
<p>以上面示例中的<code>question_location = E:/000_collection/myLeetCode/src</code>为例，比如说爬取了题号为22的题目，则会在<code>E:/000_collection/myLeetCode/src</code>文件夹下创建<code>p22</code>文件夹，最终得到<code>E:/000_collection/myLeetCode/src/p22</code></p>
<p><strong>注意：</strong>配置的路径中的斜杠必须是正斜杠<code>/</code>，别写成反斜杠了！！！</p>
<p><strong>基础包：base_package</strong></p>
<p>在settings.proterties配置文件中的属性<code>base_package</code>表示解题所在的包，这要与基本路径<code>question_location</code>中<code>src</code>之后的路径对应，否则会出错。</p>
<p>示例1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">若 question_location = E:/000_collection/myLeetCode/src</span><br><span class="line">则 base_package =</span><br><span class="line">没错，base_package就等于空，因为question_location中的src就是包的根位置</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">若 question_location = E:/000_collection/myLeetCode/src/com/leetcode</span><br><span class="line">则 base_package = com.leetcode</span><br></pre></td></tr></table></figure>



<p>对于上述的两个示例的情况，我分别实际演示一下如何配置。</p>
<p><strong>示例1：将题目爬取到<code>src</code>下</strong></p>
<ol>
<li><p>打开刚刚创建的<strong>解题项目</strong>，右键src-&gt;Copy Path-&gt;Absloute Path，也就是复制src的本地绝对路径，也可以直接到资源管理器中复制</p>
<p><img src="/posts/fe73207c/20210810155757.png" alt="复制路径"></p>
<p><img src="/posts/fe73207c/20210810155842.png" alt="复制路径"></p>
</li>
<li><p>将刚复制的路径粘贴到<strong>爬虫项目</strong>的settings.properties配置文件中的<code>question_location</code>去</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Java项目中要存放解题的根文件夹，如 E:/LeetCode/src/com/leetcode</span></span><br><span class="line"><span class="attr">question_location</span> = <span class="string">E:\000_collection\myLeetCode\src</span></span><br></pre></td></tr></table></figure>

<p>注意，此时的路径为反斜杠，将其都改为斜杠<code>/</code></p>
<p>修改后：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Java项目中要存放解题的根文件夹，如 E:/LeetCode/src/com/leetcode</span></span><br><span class="line"><span class="attr">question_location</span> = <span class="string">E:/000_collection/myLeetCode/src</span></span><br></pre></td></tr></table></figure></li>
<li><p>将<strong>爬虫项目</strong>的settings.properties配置文件中的<code>base_package</code>属性等号之后置为空</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解题所在的包 如：com.leetcode 若没有(也就是放在src文件夹下)则为空</span></span><br><span class="line"><span class="attr">base_package</span> = <span class="string"></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>示例2：将题目爬取到指定的包下</strong></p>
<p>假设我的解题项目中存在包com.leetcode，我要将题目爬取到这个包下。</p>
<ol>
<li><p>打开<strong>解题项目</strong>，右键leetcode-&gt;Copy Path-&gt;Absloute Path，也就是复制leetcode的本地绝对路径，也可以直接到资源管理器中复制</p>
<p><img src="/posts/fe73207c/20210810161348.png" alt="复制路径"></p>
</li>
<li><p>将刚复制的路径粘贴到<strong>爬虫项目</strong>的settings.properties配置文件中的<code>question_location</code>去</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Java项目中要存放解题的根文件夹，如 E:/LeetCode/src/com/leetcode</span></span><br><span class="line"><span class="attr">question_location</span> = <span class="string">E:\000_collection\myLeetCode\src\com\leetcode</span></span><br></pre></td></tr></table></figure>

<p>注意，此时的路径为反斜杠，将其都改为斜杠<code>/</code></p>
<p>修改后：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Java项目中要存放解题的根文件夹，如 E:/LeetCode/src/com/leetcode</span></span><br><span class="line"><span class="attr">question_location</span> = <span class="string">E:/000_collection/myLeetCode/src/com/leetcode</span></span><br></pre></td></tr></table></figure></li>
<li><p>将<strong>爬虫项目</strong>的settings.properties配置文件中的<code>base_package</code>属性设置为刚刚选择的包，也就是将src之后的路径中的斜杠改为点，或者你可以在刚刚选择的包（leetcode）中随便创建一个类，看一下第一行的package是什么就复制过来，别带分号就行。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解题所在的包 如：com.leetcode 若没有(也就是放在src文件夹下)则为空</span></span><br><span class="line"><span class="attr">base_package</span> = <span class="string">com.leetcode</span></span><br></pre></td></tr></table></figure>

<p>不确定的话就随便在这个包下创建一个类，看一下第一行是啥，然后再把这个类删了</p>
<p><img src="/posts/fe73207c/20210810162008.png" alt="查看包"></p>
</li>
</ol>
<h4 id="配置其他属性"><a href="#配置其他属性" class="headerlink" title="配置其他属性"></a>配置其他属性</h4><p>除了<code>question_location</code>和<code>base_package</code>的配置比较重要外，其他的配置都是与文件夹命名方式或文件命名方式有关的配置，使用默认的也挺好的。具体可以看配置文件中的注释尝试修改修改，并看看爬取后的效果，这里就不做详细的解释了，相信大家都看懂或者试出差别。这里就再把配置文件放出来吧。</p>
<p>settings.properties文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Java项目中要存放解题的根文件夹，如 E:/LeetCode/src/com/leetcode</span></span><br><span class="line"><span class="attr">question_location</span> = <span class="string">E:/000_collection/myLeetCode/src/com/leetcode</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解题所在的包 如：com.leetcode 若没有(也就是放在src文件夹下)则为空</span></span><br><span class="line"><span class="attr">base_package</span> = <span class="string">com.leetcode</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解题文件夹名称的前缀（可以是任意字符串）</span></span><br><span class="line"><span class="meta">folder.prefix</span> = <span class="string">p</span></span><br><span class="line"><span class="comment"># 解题文件夹是否包含力扣题目名（true 或 false）</span></span><br><span class="line"><span class="meta">folder.include_question_name</span> = <span class="string">true</span></span><br><span class="line"><span class="comment"># 解题文件夹是否按照时间分类（true 或 false）</span></span><br><span class="line"><span class="attr">sort_by_time</span> = <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来存储题目信息的markdown文件的前缀（可以是任意字符串）</span></span><br><span class="line"><span class="meta">question_markdown_filename.prefix</span> = <span class="string">p</span></span><br><span class="line"><span class="comment"># 用来存储题目信息的markdown文件名是否包含题目编号（true 或 false）</span></span><br><span class="line"><span class="meta">question_markdown_filename.include_question_id</span> = <span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来存储题目信息的markdown文件名是否包含题目名以及是否用中文题目名命名（true 或 false）</span></span><br><span class="line"><span class="meta">question_markdown_filename.include_question_name</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">question_markdown_filename.zh_cn</span> = <span class="string">true</span></span><br></pre></td></tr></table></figure>



<h3 id="爬取题目到本地"><a href="#爬取题目到本地" class="headerlink" title="爬取题目到本地"></a>爬取题目到本地</h3><h4 id="直接运行爬虫项目爬取"><a href="#直接运行爬虫项目爬取" class="headerlink" title="直接运行爬虫项目爬取"></a>直接运行爬虫项目爬取</h4><ol>
<li><p>运行项目</p>
<p><img src="/posts/fe73207c/20210810162906.png" alt="运行爬虫"></p>
</li>
<li><p>输入力扣中题目的英文名（地址栏中的），回车</p>
<p><img src="/posts/fe73207c/20210809214602-164839551789874.png"></p>
<p><img src="/posts/fe73207c/20210810163246.png" alt="输入题目英文名"></p>
</li>
<li><p>完成</p>
<p><img src="/posts/fe73207c/20210810163432.png" alt="题目生成完毕"></p>
</li>
</ol>
<h4 id="将项目打成jar包后爬取"><a href="#将项目打成jar包后爬取" class="headerlink" title="将项目打成jar包后爬取"></a>将项目打成jar包后爬取</h4><p>通过上面的方式已经能实现我们要的功能了，但是有个缺点就是每次都要打开项目运行，相对比较麻烦。我们可以将该项目打包成jar包，之后只要运行jar包就能运行了，且配置文件会从jar包中分离出来，可以随时修改配置，非常方便。</p>
<ol>
<li><p>回到爬虫项目中，首先双击右侧的<code>Maven-&gt;Lifecycle-&gt;clean</code>当运行结束后，再双击<code>Maven-&gt;Lifecycle-&gt;package</code></p>
<p><img src="/posts/fe73207c/20210810164926.png" alt="打包项目"></p>
</li>
<li><p>此时左侧会出现<code>target</code>文件夹，将打好的jar包（SNAPSHOT结尾的）复制出来，放到任意一个空文件夹里</p>
<p><img src="/posts/fe73207c/20210810165322.png" alt="复制打好的jar包"></p>
</li>
<li><p>可以先将复制出来的jar包重命名个短点的名字，然后打开jar包所在的文件夹，在地址栏中输入<code>cmd</code></p>
<p><img src="/posts/fe73207c/20210810170040.png" alt="打开命令行窗口"></p>
</li>
<li><p>输入命令<code>java -jar 包名.jar</code>，因为我的包名重命名为<code>LeetCodesSpider</code>所以我输入的命令就是<code>java -jar LeetCodeSpider.jar</code></p>
<p>此时会报错，系统找不到指定的路径，因为我将配置文件从jar包中分离出来了，但我们还没将配置文件放到指定的位置，所以找不到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:\000_collection\LeetCodeTool&gt;java -jar LeetCodeSpider.jar</span><br><span class="line">java.io.FileNotFoundException: src\main\resources\settings.properties (系统找不到指定的路径。)</span><br><span class="line">        at java.io.FileInputStream.open0(Native Method)</span><br><span class="line">        at java.io.FileInputStream.open(Unknown Source)</span><br><span class="line">        at java.io.FileInputStream.&lt;init&gt;(Unknown Source)</span><br><span class="line">        at java.io.FileInputStream.&lt;init&gt;(Unknown Source)</span><br><span class="line">        at config.Settings.&lt;init&gt;(Settings.java:14)</span><br><span class="line">        at SpiderApplication.main(SpiderApplication.java:15)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Unknown Source)</span><br><span class="line">        at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:48)</span><br><span class="line">        at org.springframework.boot.loader.Launcher.launch(Launcher.java:87)</span><br><span class="line">        at org.springframework.boot.loader.Launcher.launch(Launcher.java:51)</span><br><span class="line">        at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:52)</span><br><span class="line">请输入LeetCode中题目的英文名（见浏览器路径，不带斜杠）：</span><br></pre></td></tr></table></figure>

<p>既然找不到，我们就创建对应文件夹并把配置文件放到里面去就行了。</p>
<p>将报错中的<code>src\main\resources</code>复制下来。重新打开jar包所在的文件夹，在地址栏中输入<code>cmd</code>，之后输入命令创建文件夹</p>
<p><code>mkdir src\main\resources</code></p>
<p>现在打开jar包所在的文件夹我们就能看到刚创建好的文件夹了。</p>
<p><img src="/posts/fe73207c/20210810171255.png"></p>
<p>接着我们将爬虫项目中的settings.properties文件复制到<code>src\main\resources</code>文件夹下</p>
<p><img src="/posts/fe73207c/20210810171507.png" alt="复制配置文件到指定文件夹"></p>
<p>到这里还没有结束。由于我们爬取题目后会生成一些基础的代码，包括<code>Main.java</code>和<code>Solution.java</code>，而这两个文件是根据两个模板文件生成的，因此我们也要将两个模板文件放到<code>src\main\resources</code>中。</p>
<p>进入爬虫项目，复制<code>resources</code>文件夹下的整个<code>template</code>文件夹，将其粘贴到刚刚在jar包同级目录中创建的<code>src\main\resources</code>文件夹下。</p>
<p><img src="/posts/fe73207c/20210810172115.png" alt="复制template文件夹"></p>
<p><img src="/posts/fe73207c/20210810172205.png" alt="放到与settings.properties同级目录中"></p>
<p>再次在jar包所在目录打开<code>cmd</code>输入命令<code>java -jar 包名.jar</code>就能正常使用了！</p>
</li>
<li><p>编辑配置文件</p>
<p>由于配置文件与jar包分离，所以只要源代码没变，要想修改什么配置直接在jar包所在目录下的配置文件<code>src\main\resources\settings.properties</code>中修改配置属性就行了，可以用记事本vscode等任意你喜欢的文本编辑器打开修改。</p>
</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li><p>解题时题目图片显示不出来，可能是IDEA开了代理，关了就行</p>
<p><code>File-&gt;settings-&gt;Appearance &amp; Behavior-&gt;System Settings-&gt;HTTP Proxy</code>。</p>
<p><img src="/posts/fe73207c/20210810173331.png" alt="关闭代理"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>LeetCode</tag>
        <tag>刷题</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
